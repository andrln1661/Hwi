

============================================================
File: .\platformio.ini
============================================================

; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

[env:megaatmega2560]
build_flags = 
	-DESERIAL_RX_BUFFER_SIZE=256
	-DESERIAL_TX_BUFFER_SIZE=256
platform = atmelavr
board = megaatmega2560
framework = arduino
monitor_speed = 115200
lib_deps = 
	milesburton/DallasTemperature@^3.9.0
	PaulStoffregen/OneWire@^2.3.7
	arduino-libraries/ArduinoModbus@^1.0.9
	arduino-libraries/ArduinoRS485@^1.1.0


============================================================
File: .\include\Config.h
============================================================

#pragma once
#include <Arduino.h>  // Needed for pin constants


// Error codes
enum ErrorCode {
    ERR_NO_ERROR = 0,
    ERR_TEMP_LOW = 1,
    ERR_TEMP_HIGH = 2, 
    ERR_SENSOR_DISCONNECTED = 3,
    ERR_OVERCURRENT = 4,
    ERR_MODBUS_CRC_FAIL = 5,
    ERR_MODBUS_TIMEOUT = 6
};

// Serial port configuration
constexpr uint32_t BAUDRATE = 250000;

// -------------------------
// Pin Configuration
// -------------------------

// Motor control PWM output pins (software/hardware PWM)
constexpr uint8_t PWM_PINS[15] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 44, 45, 46};
constexpr uint8_t SLAVE_ID = 1;

// Motor current sensor analog input pins (ACS712 or similar)
constexpr uint8_t CURRENT_PINS[15] = {A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14};

// Motor temperature DS18B20 sensor digital input pins
constexpr uint8_t TEMP_PINS[15] = {22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36};

// System-wide sensors (also digital pins)
constexpr uint8_t WATER_TEMP_PIN = 20;  // ⚠️ Also I2C SDA
constexpr uint8_t AIR_TEMP_PIN = 21;    // ⚠️ Also I2C SCL

// Output control pins for actuators
constexpr uint8_t FAN_PIN = 40;
constexpr uint8_t MIXER_PIN = 41;
constexpr uint8_t DISPENSER_PIN = 42;
constexpr uint8_t PUMP_PIN = 43;

// -------------------------
// Modbus Register Map
// -------------------------
namespace ModbusReg {

    // --- Motor Parameters ---
    // Holding Registers (writeable by master)
    constexpr uint16_t DUTY_BASE = 1;      // Holding: [1–15] — duty cycle control
    constexpr uint16_t GLOBAL_FREQ = 0;

    // Input Registers (read-only to master)
    constexpr uint16_t CURR_BASE = 16;    // Input: [16–30] — motor current values
    constexpr uint16_t TEMP_BASE = 31;    // Input: [31–45] — motor temperature values
    constexpr uint16_t STATUS_BASE = 46;  // Input: [46–60] — motor status (e.g. overtemp, error)

    // Thresholds (Holding registers, writeable by master)
    constexpr uint16_t MOTOR_TEMP_CRIT = 61;
    constexpr uint16_t MOTOR_CURR_CRIT = 62;

    // --- System Parameters ---
    constexpr uint16_t START_REG_ADDR = 65;
    constexpr uint16_t TIME_LOW = 66;

    // Air Temp
    constexpr uint16_t AIR_TEMP_REG = 70;
    constexpr uint16_t AIR_TEMP_LOW = 71;
    constexpr uint16_t AIR_TEMP_HIGH = 72;

    // Water Temp
    constexpr uint16_t WATER_TEMP_REG = 80;
    constexpr uint16_t WATER_TEMP_LOW = 81;
    constexpr uint16_t WATER_TEMP_HIGH = 82;

    // --- Device States ---
    constexpr uint16_t DEV_STATUS_BASE = 90;
    constexpr uint16_t FAN_REG = 91;
    constexpr uint16_t MIXER_REG = 92;
    constexpr uint16_t DISPENSER_REG = 93;
    constexpr uint16_t PUMP_REG = 94;
}

// -------------------------
// Safety & Operational Limits
// -------------------------

constexpr uint8_t NUM_MOTORS = 15;

// Temperature values scaled (e.g., 5000 = 50.00°C if using hundredths of °C)
constexpr uint16_t TEMP_WARNING  = 5000;
constexpr uint16_t TEMP_CRITICAL = 6000;
constexpr uint16_t CURR_CRITICAL = 9000;     // mA or raw sensor units

// PWM frequency range (Hz)
constexpr uint16_t MIN_PWM_FREQ = 100;
constexpr uint16_t MAX_PWM_FREQ = 30000;


============================================================
File: .\include\CurrentSensor.h
============================================================

#pragma once
#include <Arduino.h>

class CurrentSensor {
public:
    CurrentSensor(uint8_t pin, uint16_t regAddr);
    void begin();
    void update(uint64_t now);
    uint16_t getCurrent() const;
    void setSmoothingFactor(float factor);
    
private:
    uint8_t pin;
    uint16_t regAddr;
    float filteredValue;
    float smoothingFactor;
    uint32_t lastSampleTime;
    
    static constexpr uint32_t SAMPLE_INTERVAL = 10; // ms
    static constexpr float DEFAULT_SMOOTHING = 0.15f;
};

============================================================
File: .\include\DeviceManager.h
============================================================


#pragma once
#include "TemperatureSensor.h"
#include "Motor.h"

class DeviceManager {
public:
    void begin();

    // Changed third parameter type to const Motor* const*
    void update(const TemperatureSensor& airSensor, 
                const TemperatureSensor& waterSensor, 
                const Motor* const* motors); // Fixed parameter type

    void controlFan(bool state);
    void controlMixer(bool state);
    void controlDispenser(bool state);
    void controlPump(bool state);
};

============================================================
File: .\include\Globals.h
============================================================

#pragma once

#include "ModbusHandler.h"
#include "DeviceManager.h"
#include "Motor.h"

extern ModbusHandler* modbusHandler;
extern DeviceManager* deviceManager;
extern Motor** motors;  // Changed from Motor* to Motor**

============================================================
File: .\include\ModbusHandler.h
============================================================

#pragma once
#include <ArduinoModbus.h>
#include <ArduinoRS485.h>
#include <Arduino.h>
#include "Config.h"

class ModbusHandler {
private:
    HardwareSerial& port;
    uint8_t slaveID;
    uint16_t dutyShadows[15];
    // uint16_t freqShadows[15];
    uint16_t globalFreqShadow;
    uint16_t deviceShadows[4];
    uint16_t startShadow;

    static constexpr uint8_t BUFFER_SIZE = 64;
    static uint8_t modbusBuffer[BUFFER_SIZE];
    static volatile uint8_t modbusIndex;
    static volatile bool frameReady;

public:
    ModbusHandler(HardwareSerial& portRef, uint8_t slaveRef);
    void begin(unsigned long baudrate = BAUDRATE);
    void task();

    uint16_t getHreg(uint16_t addr);
    uint16_t getIreg(uint16_t addr);
    void setHreg(uint16_t addr, uint16_t value);
    void setIreg(uint16_t addr, uint16_t value);

    void handleMotorWrite(uint16_t addr, uint16_t val);
    void handleDeviceWrite(int addr, uint16_t val);
    void handleSystemWrite(int addr, uint16_t val);
};

============================================================
File: .\include\Motor.h
============================================================

#pragma once
#include <Arduino.h>
#include "TemperatureSensor.h"
#include "CurrentSensor.h"  // Add include

class ModbusHandler;

class Motor {
public:
    Motor(uint8_t id, uint8_t pwmPin, uint8_t currentPin, 
          TemperatureSensor* tempSensor, ModbusHandler& modbus);
    void begin();
    void update(uint64_t now);
    void setDuty(uint16_t duty);
    void setFrequency(uint32_t freq);
    uint8_t getStatus() const;
    
private:
    uint8_t id;
    uint8_t pwmPin;
    CurrentSensor currentSensor;  // Replace currentPin with CurrentSensor
    TemperatureSensor* tempSensor;
    ModbusHandler& modbusHandler;
    uint16_t dutyCycle;
    uint8_t status;
};

============================================================
File: .\include\PWMController.h
============================================================

// PWMController.h
#pragma once
#include <Arduino.h>  // Provides types like uint8_t and utility macros like constrain()

// Class to control hardware PWM on Arduino Mega (ATmega2560)
class PWMController {
public:
    // Initializes all timers (0 to 5) into appropriate PWM mode
    static void initialize();

    // Sets the frequency for a specific pin by modifying timer prescaler or TOP
    // static void setFrequency(uint8_t pin, uint32_t freq);
    static void setGlobalFrequency(uint32_t freq);

    // Sets the duty cycle (0–1000) for a specific pin
    static void setDutyCycle(uint8_t pin, uint16_t duty);

    static uint64_t microsCustom();
    static uint64_t millisCustom();
    static void delayCustom(uint64_t ms);
    static volatile uint64_t _micros64;
    static uint32_t _us_per_overflow;
    
private:
    static uint32_t currentGlobalFreq;
    static uint16_t _timer2_top;
    static uint16_t _timer2_prescaler;
};

============================================================
File: .\include\SystemCore.h
============================================================


#pragma once
// Prevents multiple inclusions of this header file during compilation.

#include "ModbusHandler.h"     // Handles Modbus RTU communication (master-slave protocol)
#include "TemperatureSensor.h" // Interface for DS18B20 or similar temperature sensors
#include "Motor.h"             // Motor class: includes PWM, current sensing, and temperature safety
#include "DeviceManager.h"     // Manages auxiliary actuators like fan, pump, mixer, etc.
#include "Config.h"            // Global configuration constants (e.g., NUM_MOTORS)
#include <Arduino.h>           // Arduino core functions and types (pinMode, millis, digitalWrite, etc.)


// Main orchestrator of the embedded system. Handles setup, runtime control, and data flow.
class SystemCore {
public:
    // Constructor to initialize internal members (could also be used to preload configs)
    SystemCore();
    
    // Destructor to clean up dynamically allocated objects
    ~SystemCore();

    // Sets up all subsystems (sensors, motors, Modbus, etc.)
    void setup();

    // Main runtime loop. Should be called repeatedly from Arduino's loop()
    void loop();

    // Allows ModbusHandler to access private members like motors[] directly.
    // Useful for implementing indirect register callbacks.
    friend class ModbusHandler;

private:
    // --- Subsystems ---

    ModbusHandler modbus;               // Modbus RTU slave handler (interfaces with external master like Python GUI)

    TemperatureSensor airSensor;        // Ambient air temperature sensor (DS18B20 or similar)
    TemperatureSensor waterSensor;      // Water temperature sensor (same interface as above)

    TemperatureSensor* motorSensors[NUM_MOTORS]; // Array of pointers to per-motor temperature sensors

    Motor* motors[NUM_MOTORS];          // Array of pointers to core motor control objects

    DeviceManager deviceManager;        // Controls peripheral devices (fan, mixer, pump, etc.)

    uint64_t accumulated_ticks = 0;
    uint32_t last_overflow_snapshot = 0;
    uint16_t current_timer0_prescaler = 64;

    // --- Timekeeping ---

    // Custom millisecond counter (optionally extended to 64-bit for rollover-safe timing)
    uint64_t millisCustom();

    // Stores prescaler state for custom millis if using a timer overflow counter
    uint16_t prev_prescaler;
};

// Declares a global instance accessible throughout the codebase.
// Allows Modbus callbacks or interrupt handlers to refer to the central system state.
extern SystemCore systemCore;

============================================================
File: .\include\TemperatureSensor.h
============================================================


#pragma once  // Ensure the header is only included once during compilation

#include <OneWire.h>             // For communicating with 1-Wire devices like DS18B20
#include <DallasTemperature.h>   // High-level wrapper for 1-Wire temperature sensors
#include <Arduino.h>             // Core Arduino definitions and types

// Class to encapsulate a single DS18B20 temperature sensor
class TemperatureSensor {
private:
    OneWire oneWire;             // OneWire bus instance, bound to a specific pin
    DallasTemperature sensor;    // DallasTemperature library interface for reading sensor(s)
    
    uint16_t regTemp;            // Modbus register to store current temperature
    uint16_t regLowThreshold;    // Modbus register for minimum safe temperature
    uint16_t regHighThreshold;   // Modbus register for maximum safe temperature
    
    int16_t temperature;         // Last read temperature in 0.1°C precision (e.g., 254 = 25.4°C)
                                 // Changed from uint16_t to handle negative Celsius values
    uint8_t status;              // Encoded sensor status (e.g., 0=OK, 1=too low, 2=too high)
    uint64_t lastTemperatureRequest = 0; // Instance-specific timestamp

    uint32_t lastRequestTime;
    bool conversionPending;
public:
    // Constructor: specify GPIO pin and Modbus register mappings
    TemperatureSensor(uint8_t pin, uint16_t tempReg, uint16_t lowThresholdReg, uint16_t highThresholdReg);

    // Initializes OneWire and DallasTemperature libraries
    void begin();

    // Reads temperature from sensor and updates Modbus registers and status
    void update();

    // Returns latest temperature value in 0.1°C precision (e.g., 325 = 32.5°C)
    int16_t getTemperature() const;

    // Returns current status code
    uint8_t getStatus() const;

    // Read data from sensors (Take's a bit time so we need it to call before reading temps)
    void requestTemperatures(uint64_t now);

    void requestTemperaturesAsync(uint64_t now);
    bool isConversionComplete();
    void readTemperatureAsync();

};

============================================================
File: .\src\CurrentSensor.cpp
============================================================

#include "CurrentSensor.h"
#include "ModbusHandler.h"
#include "Config.h"
#include "Globals.h"

CurrentSensor::CurrentSensor(uint8_t pin, uint16_t regAddr)
    : pin(pin), regAddr(regAddr), filteredValue(0),
      smoothingFactor(DEFAULT_SMOOTHING), lastSampleTime(0) {}

void CurrentSensor::begin() {
    pinMode(pin, INPUT);
    
    // Initial reading to start filter
    uint16_t raw = analogRead(pin);
    filteredValue = raw;
}

void CurrentSensor::update(uint64_t now) {
    if (now - lastSampleTime < SAMPLE_INTERVAL) return;
    
    lastSampleTime = now;
    uint16_t raw = analogRead(pin);
    
    // Exponential smoothing
    // filteredValue = smoothingFactor * raw + (1 - smoothingFactor) * filteredValue;
    
    // Convert to mA (ACS712-5A specific conversion)
    uint16_t current = (raw - 512) * 1000 / 66;

    // Update Modbus register
    modbusHandler->setIreg(regAddr, current);
}

uint16_t CurrentSensor::getCurrent() const {
    return (filteredValue - 512) * 1000 / 66;
}

void CurrentSensor::setSmoothingFactor(float factor) {
    smoothingFactor = constrain(factor, 0.0f, 1.0f);
}

============================================================
File: .\src\DeviceManager.cpp
============================================================


#include "DeviceManager.h"
#include "ModbusHandler.h"
#include "Config.h"
#include "Globals.h"

void DeviceManager::begin() {
    pinMode(FAN_PIN, OUTPUT);
    pinMode(MIXER_PIN, OUTPUT);
    pinMode(DISPENSER_PIN, OUTPUT);
    pinMode(PUMP_PIN, OUTPUT);

    // Optional: clear state
    digitalWrite(FAN_PIN, LOW);
    digitalWrite(MIXER_PIN, LOW);
    digitalWrite(DISPENSER_PIN, LOW);
    digitalWrite(PUMP_PIN, LOW);
}

void DeviceManager::update(const TemperatureSensor& airSensor, 
                           const TemperatureSensor& waterSensor, 
                           const Motor* const* motors) {
    // --- Fan logic ---
    uint16_t airTemp = airSensor.getTemperature();
    uint16_t airLow = modbusHandler->getHreg(ModbusReg::AIR_TEMP_LOW);
    uint16_t airHigh = modbusHandler->getHreg(ModbusReg::AIR_TEMP_HIGH);
    bool fanState = false;

    if (airTemp != 0xFFFF) {
        fanState = (airTemp >= airHigh) || (airTemp <= airLow);
    }
    controlFan(fanState);

    // --- Mixer logic ---
    uint16_t waterTemp = waterSensor.getTemperature();
    uint16_t waterLow = modbusHandler->getHreg(ModbusReg::WATER_TEMP_LOW);
    uint16_t waterHigh = modbusHandler->getHreg(ModbusReg::WATER_TEMP_HIGH);
    bool mixerState = false;

    if (waterTemp != 0xFFFF) {
        mixerState = (waterTemp >= waterHigh) || (waterTemp <= waterLow);
    }
    controlMixer(mixerState);

    // --- Dispenser logic ---
    bool dispenserState = (waterTemp != 0xFFFF && waterTemp >= waterHigh);
    controlDispenser(dispenserState);

    // --- Pump logic ---
    bool pumpState = false;
    for (int i = 0; i < NUM_MOTORS; i++) {
        if (motors[i]->getStatus() < 2 && 
            modbusHandler->getHreg(ModbusReg::DUTY_BASE + i) > 0) {
            pumpState = true;
            break;
        }
    }
    controlPump(pumpState);
}

// Device control methods with Modbus feedback

void DeviceManager::controlFan(bool state) {
    digitalWrite(FAN_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 0, state ? 1 : 0);
}

void DeviceManager::controlMixer(bool state) {
    digitalWrite(MIXER_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 1, state ? 1 : 0);
}

void DeviceManager::controlDispenser(bool state) {
    digitalWrite(DISPENSER_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 2, state ? 1 : 0);
}

void DeviceManager::controlPump(bool state) {
    digitalWrite(PUMP_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 3, state ? 1 : 0);
}

============================================================
File: .\src\Globals.cpp
============================================================


#include "Globals.h"

ModbusHandler* modbusHandler = nullptr;
DeviceManager* deviceManager = nullptr;
Motor** motors = nullptr;  // Changed from Motor* to Motor**

============================================================
File: .\src\main.cpp
============================================================


#include <Arduino.h>
#include <SystemCore.h>
#include "Config.h"
#include <avr/wdt.h>

SystemCore systemCore;

void setup() {
  systemCore.setup();
  // wdt_enable(WDTO_2S);
}

void loop() {
  // wdt_enable(WDTO_2S);
  systemCore.loop();
}

============================================================
File: .\src\ModbusHandler.cpp
============================================================


#include "ModbusHandler.h"
#include "Motor.h"
#include "DeviceManager.h"
#include "Config.h"
#include "Globals.h"

ModbusHandler::ModbusHandler(HardwareSerial& portRef, uint8_t slaveRef)
    : port(portRef), slaveID(slaveRef) {}

void ModbusHandler::begin(unsigned long baudrate) {
    port.begin(baudrate);  // For logging and Modbus

    // Begin with explicit parity (even) for validation
    if (!ModbusRTUServer.begin(slaveID, baudrate, SERIAL_8E1)) {
        while (1);
    }

    // Configure ranges (larger for safety)
    ModbusRTUServer.configureHoldingRegisters(0, 100);
    ModbusRTUServer.configureInputRegisters(0, 100);

    // Init registers
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::START_REG_ADDR, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW + 1, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW + 2, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW + 3, 0);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::MOTOR_TEMP_CRIT, TEMP_CRITICAL);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::MOTOR_CURR_CRIT, CURR_CRITICAL);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::AIR_TEMP_LOW, TEMP_WARNING);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::AIR_TEMP_HIGH, TEMP_CRITICAL);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::WATER_TEMP_LOW, TEMP_WARNING);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::WATER_TEMP_HIGH, TEMP_CRITICAL);

    // Init duty and freq shadows and registers
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        ModbusRTUServer.holdingRegisterWrite(ModbusReg::DUTY_BASE + i, 0);
        dutyShadows[i] = 0;
        // ModbusRTUServer.holdingRegisterWrite(ModbusReg::FREQ_BASE + i, 1000);
        // freqShadows[i] = 1000;
    }
    memset(deviceShadows, 0, sizeof(deviceShadows));
    startShadow = 0;

}

void ModbusHandler::task() {
    static uint8_t errorCount = 0;
    
    int pollResult = ModbusRTUServer.poll();
    if (pollResult == -1) {
        if (++errorCount > 10) {
            // Reset Modbus state after 10 errors
            ModbusRTUServer.begin(slaveID, BAUDRATE, SERIAL_8E1);
            errorCount = 0;
        }
    } else {
        errorCount = 0;
    }
    if (!port.available()) return;

    // int pollResult = ModbusRTUServer.poll();
    // if (pollResult == -1) {
    //     // Error handling (e.g., frame/CRC error); increment counter or log
    // }

    // Check for changes in holding registers (reactive handling)
    uint16_t globalFreq = ModbusRTUServer.holdingRegisterRead(ModbusReg::GLOBAL_FREQ);
    if (globalFreqShadow != globalFreq) {
        handleMotorWrite(ModbusReg::GLOBAL_FREQ, globalFreq);
        globalFreqShadow = globalFreq;
    }
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        uint16_t dutyVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::DUTY_BASE + i);
        if (dutyVal != dutyShadows[i]) {
            handleMotorWrite(ModbusReg::DUTY_BASE + i, dutyVal);
            dutyShadows[i] = dutyVal;
        }
        // uint16_t freqVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::FREQ_BASE + i);
        // if (freqVal != freqShadows[i]) {
            // handleMotorWrite(ModbusReg::FREQ_BASE + i, freqVal);
            // freqShadows[i] = freqVal;
        // }
    }
    for (uint8_t i = 0; i < 4; i++) {
        uint16_t devVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::DEV_STATUS_BASE + i);
        if (devVal != deviceShadows[i]) {
            handleDeviceWrite(ModbusReg::DEV_STATUS_BASE + i, devVal);
            deviceShadows[i] = devVal;
        }
    }
    uint16_t startVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::START_REG_ADDR);
    if (startVal != startShadow) {
        handleSystemWrite(ModbusReg::START_REG_ADDR, startVal);
        startShadow = startVal;
    }
}

uint16_t ModbusHandler::getHreg(uint16_t addr) {
    return ModbusRTUServer.holdingRegisterRead(addr);
}

uint16_t ModbusHandler::getIreg(uint16_t addr) {
    return ModbusRTUServer.inputRegisterRead(addr);
}

void ModbusHandler::setHreg(uint16_t addr, uint16_t value) {
    ModbusRTUServer.holdingRegisterWrite(addr, value);
}

void ModbusHandler::setIreg(uint16_t addr, uint16_t value) {
    ModbusRTUServer.inputRegisterWrite(addr, value);
}

void ModbusHandler::handleMotorWrite(uint16_t addr, uint16_t val) {  // Changed parameter type to uint16_t
    if (addr >= ModbusReg::DUTY_BASE &&
        addr < ModbusReg::DUTY_BASE + NUM_MOTORS) {
        uint8_t id = addr - ModbusReg::DUTY_BASE;
        motors[id]->setDuty(val);
    } 
    else if (addr == ModbusReg::GLOBAL_FREQ) {
        globalFreqShadow = val;
        // PWMController::setGlobalFrequency(val);
        motors[1]->setFrequency(val);
    }
    // else if (addr >= ModbusReg::FREQ_BASE &&
            //    addr < ModbusReg::FREQ_BASE + NUM_MOTORS) {
        // uint8_t id = addr - ModbusReg::FREQ_BASE;
        // motors[id]->setFrequency(val);
    // }
}

void ModbusHandler::handleDeviceWrite(int addr, uint16_t val) {
    if (addr == ModbusReg::FAN_REG) deviceManager->controlFan(val > 0);
    else if (addr == ModbusReg::MIXER_REG) deviceManager->controlMixer(val > 0);
    else if (addr == ModbusReg::DISPENSER_REG) deviceManager->controlDispenser(val > 0);
    else if (addr == ModbusReg::PUMP_REG) deviceManager->controlPump(val > 0);
}

void ModbusHandler::handleSystemWrite(int addr, uint16_t val) {
    if (val == 0) {
        for (int i = 0; i < NUM_MOTORS; i++) {
            motors[i]->setDuty(0);
        }
        deviceManager->controlFan(false);
        deviceManager->controlMixer(false);
        deviceManager->controlDispenser(false);
        deviceManager->controlPump(false);
    }
}

============================================================
File: .\src\Motor.cpp
============================================================

#include "Motor.h"
#include "PWMController.h"
#include "ModbusHandler.h"
#include "Config.h"
#include "Globals.h"

Motor::Motor(uint8_t id, uint8_t pwmPin, uint8_t currentPin, 
             TemperatureSensor* tempSensor, ModbusHandler& modbus)
    : id(id), pwmPin(pwmPin), 
      currentSensor(currentPin, ModbusReg::CURR_BASE + id),  // Initialize CurrentSensor
      tempSensor(tempSensor), modbusHandler(modbus),
      dutyCycle(0), status(0) {}

void Motor::begin() {
    pinMode(pwmPin, OUTPUT);
    currentSensor.begin();  // Initialize current sensor
    
    // PWMController::setFrequency(pwmPin, 1000);
    PWMController::setGlobalFrequency(7812);
    PWMController::setDutyCycle(pwmPin, 0);
}

void Motor::update(uint64_t now) {
    currentSensor.update(now);  // Update current reading
    
    int16_t temp = tempSensor->getTemperature();
    modbusHandler.setIreg(ModbusReg::TEMP_BASE + id, static_cast<uint16_t>(temp));

    uint8_t tempStatus = tempSensor->getStatus();
    uint16_t current = currentSensor.getCurrent();  // Get current from sensor

    modbusHandler.setIreg(ModbusReg::STATUS_BASE + id, status);
}


void Motor::setDuty(uint16_t duty) {
    PWMController::setDutyCycle(pwmPin, duty);
}

void Motor::setFrequency(uint32_t freq) {
    PWMController::setGlobalFrequency(freq);
}

uint8_t Motor::getStatus() const {
    return status;
}

============================================================
File: .\src\PWMController.cpp
============================================================

// PWMController.cpp
#include "PWMController.h"
#include "Config.h"     // Contains MIN_PWM_FREQ and MAX_PWM_FREQ
#include <Arduino.h>
#include <avr/io.h>     // Direct access to AVR timer registers

volatile uint64_t PWMController::_micros64 = 0;
uint16_t PWMController::_timer2_top = 0xFF;
uint16_t PWMController::_timer2_prescaler = 8;
uint32_t PWMController::_us_per_overflow = 128; // Default for 7812 Hz

// Timer 2 overflow interrupt
ISR(TIMER2_OVF_vect) {
    PWMController::_micros64 += PWMController::_us_per_overflow;
}

uint64_t PWMController::microsCustom() {
    uint64_t m;
    cli();
    m = _micros64;
    sei();
    return m;
}

uint64_t PWMController::millisCustom() {
    return microsCustom() / 1000;
}

void PWMController::delayCustom(uint64_t ms) {
    uint64_t start = millisCustom();
    while (millisCustom() - start < ms);
}

// Initialize all timers (Timer0–Timer5) in PWM mode
void PWMController::initialize() {
    // Ensure pins are outputs
    // pinMode(13, OUTPUT); // PB7: OC1C (Timer1) — repurposed from OC0A
    // pinMode(4,  OUTPUT); // PG5: OC0B (Timer0)

    // ---------------- Timer 0: Pin 4 (OC0B) with OCR0A as TOP ----------------
    // Fast PWM with OCR0A as TOP (WGM02:0 = 7). OC0B enabled, OC0A disconnected.
    // TCCR0A = _BV(WGM00) | _BV(WGM01) | _BV(COM0B1);
    // TCCR0B = _BV(WGM02) | _BV(CS00); // prescaler = /1
    // OCR0A  = 0xFF;
    // OCR0B  = 0x00;


    TIMSK2 |= (1 << TOIE2);
    TIMSK0 &= ~(1 << TOIE0);
  

    // ---------------- Timer 1: Pins 11 (OC1A), 12 (OC1B), 13 (OC1C) ----------------
    // Mode 14 Fast PWM, TOP=ICR1
    TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(COM1C1) | _BV(WGM11);
    TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // prescaler = /1
    ICR1   = 2048;

    // ---------------- Timer 2: Pins 9,10 (OC2A,OC2B) ----------------
    // Fast PWM, fixed prescaler choices
    TCCR2A = _BV(WGM20) | _BV(WGM21) | _BV(COM2A1) | _BV(COM2B1);
    TCCR2B = _BV(CS21);

    // ---------------- Timer 3: Pins 5,2,3 (OC3A/OC3B/OC3C) ----------------
    TCCR3A = _BV(COM3A1) | _BV(COM3B1) | _BV(WGM31);
    TCCR3B = _BV(WGM33) | _BV(WGM32) | _BV(CS30);
    ICR3   = 2048;

    // ---------------- Timer 4: Pins 6,7,8 (OC4A/OC4B/OC4C) ----------------
    TCCR4A = _BV(COM4A1) | _BV(COM4B1) | _BV(WGM41);
    TCCR4B = _BV(WGM43) | _BV(WGM42) | _BV(CS40);
    ICR4   = 2048;

    // ---------------- Timer 5: Pins 46 (OC5A), 45 (OC5B), 44 (OC5C) ----------------
    TCCR5A = _BV(COM5A1) | _BV(COM5B1) | _BV(WGM51);               // Fast PWM, Mode 14
    TCCR5B = _BV(WGM53) | _BV(WGM52) | _BV(CS50);                  // Prescaler = /1
    ICR5   = 2048;
}

// Default global frequency
void PWMController::setGlobalFrequency(uint32_t freq) {
    // Timer 0 (8-bit): Pin 4

    // Timer 2 (8-bit): Pins 9, 10 
    if (freq >= 10000)       {TCCR2B = (TCCR2B & 0xF8) | 0x01; _timer2_prescaler = 1;}
    else if (freq >= 5000)  {TCCR2B = (TCCR2B & 0xF8) | 0x02;  _timer2_prescaler = 8;}
    else if (freq >= 2000)  {TCCR2B = (TCCR2B & 0xF8) | 0x03; _timer2_prescaler = 32;}
    else if (freq >= 1000)   {TCCR2B = (TCCR2B & 0xF8) | 0x04; _timer2_prescaler = 64;}
    else if (freq >= 500)   {TCCR2B = (TCCR2B & 0xF8) | 0x05; _timer2_prescaler = 128;}
    else if (freq >= 200)    {TCCR2B = (TCCR2B & 0xF8) | 0x06; _timer2_prescaler = 256;}
    else                     {TCCR2B = (TCCR2B & 0xF8) | 0x07; _timer2_prescaler = 512;}
    _timer2_top = 0xFF;
    _us_per_overflow = (1000000UL * _timer2_prescaler * (_timer2_top + 1)) / F_CPU;
    
    // Ensure Timer2 interrupt is enabled
    TIMSK2 |= (1 << TOIE2);

    // Timers 1, 3, 4, 5 (16-bit): pins 2, 3, 5, 6, 7, 8, 11, 12...is switched from Timer 2 to Timer 1 channel C in initialization)
    // Let timebase code handle Timer1 prescaler to preserve time accounting.
    TCCR1B = (TCCR1B & 0xF8) | 0x01;
    TCCR3B = (TCCR3B & 0xF8) | 0x01;
    TCCR4B = (TCCR4B & 0xF8) | 0x01;
    TCCR5B = (TCCR5B & 0xF8) | 0x01;

    // f = F_CPU / (prescaler * (1 + TOP)), with prescaler = 1:
    uint32_t top = (F_CPU / (1UL * freq));
    if (top > 0) top -= 1;
    if (top < 1) top = 1;           // avoid TOP=0
    if (top > 65535UL) top = 65535; // with prescaler=1, this caps at ~244 Hz

    // Program Timer1 TOP via timebase API so timebase snapshots prior epoch
    ICR1 = uint16_t(top);
    ICR3 = uint16_t(top);
    ICR4 = uint16_t(top);
    ICR5 = uint16_t(top);
}

// Set PWM duty cycle (0–1000) for the given pin
void PWMController::setDutyCycle(uint8_t pin, uint16_t duty) {
    noInterrupts();
    duty = constrain(duty, 0, 100);  // per-mille (0–1000)
    uint16_t ocrValue = 0;

    switch (pin) {
        // --- Timer1 (ICR1 as TOP) ---
        case 11: ocrValue = (uint32_t)duty * ICR1 / 100UL; OCR1A = ocrValue; break;
        case 12: ocrValue = (uint32_t)duty * ICR1 / 100UL; OCR1B = ocrValue; break;
        case 13: ocrValue = (uint32_t)duty * ICR1 / 100UL; OCR1C = ocrValue; break;

        // --- Timer3 (ICR3 as TOP) ---
        case 5:  ocrValue = (uint32_t)duty * ICR3 / 100UL; OCR3A = ocrValue; break;
        case 2:  ocrValue = (uint32_t)duty * ICR3 / 100UL; OCR3B = ocrValue; break;
        case 3:  ocrValue = (uint32_t)duty * ICR3 / 100UL; OCR3C = ocrValue; break;

        // --- Timer4 (ICR4 as TOP) ---
        case 6:  ocrValue = (uint32_t)duty * ICR4 / 100UL; OCR4A = ocrValue; break;
        case 7:  ocrValue = (uint32_t)duty * ICR4 / 100UL; OCR4B = ocrValue; break;
        case 8:  ocrValue = (uint32_t)duty * ICR4 / 100UL; OCR4C = ocrValue; break;

        // --- Timer2 (8-bit, TOP=255) ---
        case 9:  ocrValue = (uint32_t)duty * 255 / 100UL; OCR2B = ocrValue; break;
        case 10: ocrValue = (uint32_t)duty * 255 / 100UL; OCR2A = ocrValue; break;

        // --- Timer0 (Fast PWM, TOP=OCR0A) ---
        // case 4:  ocrValue = (uint32_t)duty * OCR0A / 1000UL; OCR0B = ocrValue; break;

        // --- Timer5 (ICR5 as TOP) ---
        case 46: ocrValue = (uint32_t)duty * ICR5 / 100UL; OCR5A = ocrValue; break;
        case 45: ocrValue = (uint32_t)duty * ICR5 / 100UL; OCR5B = ocrValue; break;
        case 44: ocrValue = (uint32_t)duty * ICR5 / 100UL; OCR5C = ocrValue; break;
    }
    interrupts();
}


============================================================
File: .\src\SystemCore.cpp
============================================================


#include "Globals.h"
#include "SystemCore.h"
#include "Config.h"
#include "PWMController.h"   // Add this line

SystemCore::SystemCore()
    : modbus(Serial, SLAVE_ID),
      airSensor(AIR_TEMP_PIN, 
                ModbusReg::AIR_TEMP_REG,
                ModbusReg::AIR_TEMP_LOW,
                ModbusReg::AIR_TEMP_HIGH),
      waterSensor(WATER_TEMP_PIN, 
                  ModbusReg::WATER_TEMP_REG,
                  ModbusReg::WATER_TEMP_LOW,
                  ModbusReg::WATER_TEMP_HIGH),
      prev_prescaler(0) {
    ::modbusHandler = &modbus;
    ::deviceManager = &deviceManager;
    ::motors = this->motors;  // Update global pointer to motor array

    // Initialize motor sensors with dynamic allocation
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motorSensors[i] = new TemperatureSensor(
            TEMP_PINS[i], 
            ModbusReg::TEMP_BASE + i,
            ModbusReg::MOTOR_TEMP_CRIT,
            0  // High threshold not used for motors
        );
    }
    
    // Initialize motors with dynamic allocation
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motors[i] = new Motor(
            i, 
            PWM_PINS[i], 
            CURRENT_PINS[i], 
            motorSensors[i],  // Pass pointer to sensor
            this->modbus
        );
    }
}

SystemCore::~SystemCore() {
    // Clean up dynamically allocated objects
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        delete motorSensors[i];
        delete motors[i];
    }
}

void SystemCore::setup() {
    modbus.begin();
    
    // Initialize sensors
    airSensor.begin();
    waterSensor.begin();
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motorSensors[i]->begin();  // Pointer access
    }
    
    // Initialize motors
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motors[i]->begin();  // Pointer access
    }
    
    PWMController::initialize();
    // Initialize devices
    deviceManager.begin();
}

void SystemCore::loop() {
    static uint8_t currentSensor = 0;

    
    static uint64_t lastMotorUpdate = 0;
    static uint64_t lastTempUpdate = 0;
    uint64_t now = PWMController::millisCustom();

        modbus.setIreg(ModbusReg::TIME_LOW, uint16_t(now & 0xFFFF));
        modbus.setIreg(ModbusReg::TIME_LOW + 1, uint16_t((now >> 16) & 0xFFFF));
        modbus.setIreg(ModbusReg::TIME_LOW + 2, uint16_t((now >> 32) & 0xFFFF));
        modbus.setIreg(ModbusReg::TIME_LOW + 3, uint16_t((now >> 48) & 0xFFFF));

    modbus.task();
    
    // Update motor status every 500ms
    if (now - lastMotorUpdate >= 500) {
        lastMotorUpdate = now;
        for (uint8_t i = 0; i < NUM_MOTORS; i += 3) { // Process 2 motors per cycle
            if (i < NUM_MOTORS) motors[i]->update(now);
            if (i+1 < NUM_MOTORS) motors[i+1]->update(now);
            if (i+2 < NUM_MOTORS) motors[i+2]->update(now);
            modbus.task(); // Handle Modbus between batches
        }
    }

    // Update temperature and devices every 1000ms
    if (now - lastTempUpdate >= 1000) {
        lastTempUpdate = now;

        // Request temperatures first
        for (uint8_t i = 0; i < NUM_MOTORS; i++) {
            motorSensors[i]->requestTemperaturesAsync(now);  // Pointer access
        }

        // Then update all temperature readings
        for (uint8_t i = 0; i < NUM_MOTORS; i++) {
            motorSensors[i]->update();  // Pointer access
        }

        airSensor.update();
        waterSensor.update();
        
        // Update devices (pass pointer to motor array)
        deviceManager.update(airSensor, waterSensor, motors);
        
        // Update timestamp register
    }
}



============================================================
File: .\src\TemperatureSensor.cpp
============================================================

#include "TemperatureSensor.h"
#include "ModbusHandler.h"
#include "Config.h"
#include "Globals.h"


// Constructor: initializes sensor objects and register mappings
TemperatureSensor::TemperatureSensor(uint8_t pin, uint16_t tempReg, 
                     uint16_t lowThresholdReg, uint16_t highThresholdReg) 
    : oneWire(pin),                // Initialize OneWire bus on specified pin
      sensor(&oneWire),           // Bind DallasTemperature instance to OneWire bus
      regTemp(tempReg),           // Register for current temperature value
      regLowThreshold(lowThresholdReg),   // Register for low temperature threshold
      regHighThreshold(highThresholdReg), // Register for high temperature threshold
      temperature(0),             // Initialize temperature to 0
      status(0) {}                // Initial status: normal

// Initializes the temperature sensor hardware
void TemperatureSensor::begin() {
    sensor.begin();               // Initialize DallasTemperature library
    sensor.setResolution(10);     // Set sensor resolution (11 bits = 0.125°C precision)
    sensor.setWaitForConversion(false);
}

void TemperatureSensor::requestTemperatures(uint64_t now) {
    if (now - lastTemperatureRequest > 1000) {
        sensor.requestTemperatures(); // Trigger temperature reading from DS18B20
        lastTemperatureRequest = now;
    }
}

void TemperatureSensor::requestTemperaturesAsync(uint64_t now) {
    if (!conversionPending && (now - lastRequestTime > 1000)) {
        sensor.requestTemperatures();
        conversionPending = true;
        lastRequestTime = now;
    }
}

bool TemperatureSensor::isConversionComplete() {
    if (conversionPending) {
        conversionPending = !sensor.isConversionComplete();
        return !conversionPending;
    }
    return false;
}

// Reads temperature, checks thresholds, and updates Modbus registers
void TemperatureSensor::update() {
    if (conversionPending && sensor.isConversionComplete()) {
        float tempC = sensor.getTempCByIndex(0); // Read the first sensor on the bus
    
        if (tempC == DEVICE_DISCONNECTED_C) {
            // Handle sensor disconnect case
            temperature = -32768;     // INT16_MIN sentinel value to indicate error
            status = 3;               // Status code for disconnected
        } else {
            // Convert temperature to centi-degrees (e.g., 25.34°C → 2534)
            temperature = static_cast<int16_t>(tempC * 100); 
            
            // Read threshold values from holding registers
            uint16_t lowThreshold = modbusHandler->getHreg(regLowThreshold);
            uint16_t highThreshold = modbusHandler->getHreg(regHighThreshold);

            // Compare and classify temperature status
            if (temperature >= static_cast<int16_t>(highThreshold))
                status = 2; // Temperature above upper limit
            else if (temperature <= static_cast<int16_t>(lowThreshold))
                status = 1; // Temperature below lower limit
            else
                status = 0; // Temperature within acceptable range
        }

        // Write temperature to input register (read-only from master perspective)
        modbusHandler->setIreg(regTemp, static_cast<uint16_t>(temperature));
        // Note: If temperature is negative, casting to uint16_t will wrap around,
        // which may need special handling on Modbus master side.
        conversionPending = false;
    }
}

// Getter: returns raw centi-degree temperature value (can be negative)
// int16_t TemperatureSensor::getTemperature() const {
//     if (temperature < 0) {
//         return 0;
//     }
//     return temperature;
// }
int16_t TemperatureSensor::getTemperature() const {
    return temperature;
}

// Getter: returns current status flag (0=OK, 1=Low, 2=High, 3=Disconnected)
uint8_t TemperatureSensor::getStatus() const {
    return status;
}