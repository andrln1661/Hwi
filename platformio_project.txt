# PlatformIO Project Files


================================================================================
File: platformio.ini
================================================================================


; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

[env:megaatmega2560]
build_flags = 
	-DESERIAL_RX_BUFFER_SIZE=256
	-DESERIAL_TX_BUFFER_SIZE=256
platform = atmelavr
board = megaatmega2560
framework = arduino
monitor_speed = 115200 
lib_deps = 
	milesburton/DallasTemperature@^3.9.0
	PaulStoffregen/OneWire@^2.3.7
	arduino-libraries/ArduinoModbus@^1.0.9
	arduino-libraries/ArduinoRS485@^1.1.0

================================================================================
File: platformio_project.txt
================================================================================



================================================================================
File: qwen-cpp-txt.py
================================================================================

import os
import argparse
from pathlib import Path

def combine_platformio_files(root_dir, output_file, exclude_dirs=None, exclude_extensions=None):
    """
    Combines common PlatformIO project files into a single text file with clear separation.
    
    Args:
        root_dir (str): Root directory to search for files
        output_file (str): Output text file path
        exclude_dirs (list): List of directory names to exclude
        exclude_extensions (list): List of file extensions to exclude
    """
    if exclude_dirs is None:
        exclude_dirs = ['.git', '.svn', '.pio', '.vscode', 'lib_deps']
    
    if exclude_extensions is None:
        exclude_extensions = ['.png', '.jpg', '.jpeg', '.gif', '.ico', '.bin', '.hex', '.elf', '.o', '.a', '.so', '.dll', '.exe']
    
    # Common PlatformIO file extensions and names to include
    include_extensions = [
        '.py', '.ini', '.txt', '.md', '.yaml', '.yml', '.json', '.xml', 
        '.cpp', '.c', '.h', '.hpp', '.ino', '.S', '.ld', '.cfg'
    ]
    
    include_names = [
        'platformio.ini', 'README', 'README.md', 'LICENSE', 'library.json', 
        'library.properties', 'keywords.txt', 'platform.txt', 'boards.txt'
    ]
    
    with open(output_file, 'w', encoding='utf-8') as outfile:
        outfile.write("# PlatformIO Project Files\n\n")
        
        # Use rglob to recursively find all files
        for file_path in Path(root_dir).rglob("*"):
            # Skip if it's a directory
            if file_path.is_dir():
                continue
                
            # Skip excluded directories
            if any(excluded in file_path.parts for excluded in exclude_dirs):
                continue
                
            # Skip excluded extensions
            if file_path.suffix.lower() in exclude_extensions:
                continue
                
            # Include files with specific extensions or names
            if (file_path.suffix.lower() in include_extensions or 
                file_path.name in include_names or
                file_path.name.lower().startswith('readme')):
                
                relative_path = file_path.relative_to(root_dir)
                try:
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        
                    # Write clear file separation
                    outfile.write(f"\n{'='*80}\n")
                    outfile.write(f"File: {relative_path}\n")
                    outfile.write(f"{'='*80}\n\n")
                    outfile.write(content)
                    outfile.write("\n")
                    
                except UnicodeDecodeError:
                    # Handle binary files that might have slipped through
                    outfile.write(f"\n{'='*80}\n")
                    outfile.write(f"File: {relative_path}\n")
                    outfile.write(f"{'='*80}\n")
                    outfile.write("[Binary file - content not included]\n\n")
                except Exception as e:
                    print(f"Warning: Could not read {relative_path}: {e}")

def main():
    parser = argparse.ArgumentParser(description="Combine PlatformIO project files into a single text file")
    parser.add_argument("project_dir", help="PlatformIO project directory path")
    parser.add_argument("-o", "--output", default="platformio_project.txt", 
                        help="Output file name (default: platformio_project.txt)")
    parser.add_argument("-e", "--exclude", nargs='*', default=None,
                        help="Additional directories to exclude")
    parser.add_argument("--exclude-ext", nargs='*', default=None,
                        help="Additional file extensions to exclude")
    
    args = parser.parse_args()
    
    # Prepare exclusion list
    exclude_dirs = ['.git', '.pio', '.vscode', '.svn']
    if args.exclude:
        exclude_dirs.extend(args.exclude)
        
    exclude_ext = ['.png', '.jpg', '.jpeg', '.gif', '.ico', '.bin', '.hex']
    if args.exclude_ext:
        exclude_ext.extend(args.exclude_ext)
    
    # Verify project directory exists
    if not os.path.isdir(args.project_dir):
        print(f"Error: Directory '{args.project_dir}' does not exist")
        return
    
    # Combine files
    combine_platformio_files(args.project_dir, args.output, exclude_dirs, exclude_ext)
    print(f"Combined PlatformIO files saved to: {args.output}")

if __name__ == "__main__":
    main()

================================================================================
File: include\Config.h
================================================================================

#pragma once
#include <Arduino.h>  // Needed for pin constants


// Error codes
enum ErrorCode {
    ERR_NO_ERROR = 0,
    ERR_TEMP_LOW = 1,
    ERR_TEMP_HIGH = 2, 
    ERR_SENSOR_DISCONNECTED = 3,
    ERR_OVERCURRENT = 4,
    ERR_MODBUS_CRC_FAIL = 5,
    ERR_MODBUS_TIMEOUT = 6
};

// Serial port configuration
constexpr uint32_t BAUDRATE = 115200;

// -------------------------
// Pin Configuration
// -------------------------

// Motor control PWM output pins (software/hardware PWM)
constexpr uint8_t PWM_PINS[15] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 44, 45, 46};
constexpr uint8_t SLAVE_ID = 1;

// Motor current sensor analog input pins (ACS712 or similar)
constexpr uint8_t CURRENT_PINS[15] = {A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14};

// Motor temperature DS18B20 sensor digital input pins
constexpr uint8_t TEMP_PINS[15] = {22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36};

// System-wide sensors (also digital pins)
constexpr uint8_t WATER_TEMP_PIN = 20;  // ⚠️ Also I2C SDA
constexpr uint8_t AIR_TEMP_PIN = 21;    // ⚠️ Also I2C SCL

// Output control pins for actuators
constexpr uint8_t FAN_PIN = 40;
constexpr uint8_t MIXER_PIN = 41;
constexpr uint8_t DISPENSER_PIN = 42;
constexpr uint8_t PUMP_PIN = 43;

// -------------------------
// Modbus Register Map
// -------------------------
namespace ModbusReg {

    // --- Motor Parameters ---
    // Holding Registers (writeable by master)
    constexpr uint16_t DUTY_BASE = 0;      // Holding: [0–14] — duty cycle control
    // constexpr uint16_t FREQ_BASE = 100;    // Holding: [100–114] — frequency control
    constexpr uint16_t GLOBAL_FREQ = 100;

    // Input Registers (read-only to master)
    constexpr uint16_t CURR_BASE = 200;    // Input: [200–214] — motor current values
    constexpr uint16_t TEMP_BASE = 300;    // Input: [300–314] — motor temperature values
    constexpr uint16_t STATUS_BASE = 400;  // Input: [400–414] — motor status (e.g. overtemp, error)

    // Thresholds (Holding registers, writeable by master)
    constexpr uint16_t MOTOR_TEMP_CRIT = 500;
    constexpr uint16_t MOTOR_CURR_CRIT = 501;

    // --- System Parameters ---
    constexpr uint16_t START_REG_ADDR = 900;
    constexpr uint16_t TIME_LOW = 901;

    // Air Temp
    constexpr uint16_t AIR_TEMP_REG = 920;
    constexpr uint16_t AIR_TEMP_LOW = 921;
    constexpr uint16_t AIR_TEMP_HIGH = 922;

    // Water Temp
    constexpr uint16_t WATER_TEMP_REG = 930;
    constexpr uint16_t WATER_TEMP_LOW = 931;
    constexpr uint16_t WATER_TEMP_HIGH = 932;

    // --- Device States ---
    constexpr uint16_t DEV_STATUS_BASE = 911;
    constexpr uint16_t FAN_REG = 911;
    constexpr uint16_t MIXER_REG = 912;
    constexpr uint16_t DISPENSER_REG = 913;
    constexpr uint16_t PUMP_REG = 914;
}

// -------------------------
// Safety & Operational Limits
// -------------------------

constexpr uint8_t NUM_MOTORS = 15;

// Temperature values scaled (e.g., 5000 = 50.00°C if using hundredths of °C)
constexpr uint16_t TEMP_WARNING  = 5000;
constexpr uint16_t TEMP_CRITICAL = 6000;
constexpr uint16_t CURR_CRITICAL = 900;     // mA or raw sensor units

// PWM frequency range (Hz)
constexpr uint16_t MIN_PWM_FREQ = 100;
constexpr uint16_t MAX_PWM_FREQ = 30000;


================================================================================
File: include\CurrentSensor.h
================================================================================

#pragma once
#include <Arduino.h>

class CurrentSensor {
public:
    CurrentSensor(uint8_t pin, uint16_t regAddr);
    void begin();
    void update(uint64_t now);
    uint16_t getCurrent() const;
    void setSmoothingFactor(float factor);
    
private:
    uint8_t pin;
    uint16_t regAddr;
    float filteredValue;
    float smoothingFactor;
    uint32_t lastSampleTime;
    
    static constexpr uint32_t SAMPLE_INTERVAL = 10; // ms
    static constexpr float DEFAULT_SMOOTHING = 0.15f;
};

================================================================================
File: include\DeviceManager.h
================================================================================


#pragma once
#include "TemperatureSensor.h"
#include "Motor.h"

class DeviceManager {
public:
    void begin();

    // Changed third parameter type to const Motor* const*
    void update(const TemperatureSensor& airSensor, 
                const TemperatureSensor& waterSensor, 
                const Motor* const* motors); // Fixed parameter type

    void controlFan(bool state);
    void controlMixer(bool state);
    void controlDispenser(bool state);
    void controlPump(bool state);
};

================================================================================
File: include\Globals.h
================================================================================

#pragma once

#include "ModbusHandler.h"
#include "DeviceManager.h"
#include "Motor.h"

extern ModbusHandler* modbusHandler;
extern DeviceManager* deviceManager;
extern Motor** motors;  // Changed from Motor* to Motor**

================================================================================
File: include\ModbusHandler.h
================================================================================

#pragma once
#include <ArduinoModbus.h>
#include <ArduinoRS485.h>
#include <Arduino.h>
#include "Config.h"

class ModbusHandler {
private:
    HardwareSerial& port;
    uint8_t slaveID;
    uint16_t dutyShadows[15];
    // uint16_t freqShadows[15];
    uint16_t globalFreqShadow;
    uint16_t deviceShadows[4];
    uint16_t startShadow;

    static constexpr uint8_t BUFFER_SIZE = 64;
    static uint8_t modbusBuffer[BUFFER_SIZE];
    static volatile uint8_t modbusIndex;
    static volatile bool frameReady;

public:
    ModbusHandler(HardwareSerial& portRef, uint8_t slaveRef);
    void begin(unsigned long baudrate = BAUDRATE);
    void task();

    uint16_t getHreg(uint16_t addr);
    uint16_t getIreg(uint16_t addr);
    void setHreg(uint16_t addr, uint16_t value);
    void setIreg(uint16_t addr, uint16_t value);

    void handleMotorWrite(uint16_t addr, uint16_t val);
    void handleDeviceWrite(int addr, uint16_t val);
    void handleSystemWrite(int addr, uint16_t val);
};

================================================================================
File: include\Motor.h
================================================================================

#pragma once
#include <Arduino.h>
#include "TemperatureSensor.h"
#include "CurrentSensor.h"  // Add include

class ModbusHandler;

class Motor {
public:
    Motor(uint8_t id, uint8_t pwmPin, uint8_t currentPin, 
          TemperatureSensor* tempSensor, ModbusHandler& modbus);
    void begin();
    void update(uint64_t now);
    void setDuty(uint16_t duty);
    void setFrequency(uint32_t freq);
    uint8_t getStatus() const;
    
private:
    uint8_t id;
    uint8_t pwmPin;
    CurrentSensor currentSensor;  // Replace currentPin with CurrentSensor
    TemperatureSensor* tempSensor;
    ModbusHandler& modbusHandler;
    uint16_t dutyCycle;
    uint8_t status;
};

================================================================================
File: include\PWMController.h
================================================================================


// PWMController.h
#pragma once
#include <Arduino.h>  // Provides types like uint8_t and utility macros like constrain()

// Class to control hardware PWM on Arduino Mega (ATmega2560)
class PWMController {
public:
    // Initializes all timers (0 to 5) into appropriate PWM mode
    static void initialize();

    // Sets the frequency for a specific pin by modifying timer prescaler or TOP
    // static void setFrequency(uint8_t pin, uint32_t freq);
    static void setGlobalFrequency(uint32_t freq);

    // Sets the duty cycle (0–1000) for a specific pin
    static void setDutyCycle(uint8_t pin, uint16_t duty);
private:
    static uint32_t currentGlobalFreq;
};

================================================================================
File: include\README
================================================================================


This directory is intended for project header files.

A header file is a file containing C declarations and macro definitions
to be shared between several project source files. You request the use of a
header file in your project source file (C, C++, etc) located in `src` folder
by including it, with the C preprocessing directive `#include'.

```src/main.c

#include "header.h"

int main (void)
{
 ...
}
```

Including a header file produces the same results as copying the header file
into each source file that needs it. Such copying would be time-consuming
and error-prone. With a header file, the related declarations appear
in only one place. If they need to be changed, they can be changed in one
place, and programs that include the header file will automatically use the
new version when next recompiled. The header file eliminates the labor of
finding and changing all the copies as well as the risk that a failure to
find one copy will result in inconsistencies within a program.

In C, the convention is to give header files names that end with `.h'.

Read more about using header files in official GCC documentation:

* Include Syntax
* Include Operation
* Once-Only Headers
* Computed Includes

https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html


================================================================================
File: include\SystemCore.h
================================================================================


#pragma once
// Prevents multiple inclusions of this header file during compilation.

#include "ModbusHandler.h"     // Handles Modbus RTU communication (master-slave protocol)
#include "TemperatureSensor.h" // Interface for DS18B20 or similar temperature sensors
#include "Motor.h"             // Motor class: includes PWM, current sensing, and temperature safety
#include "DeviceManager.h"     // Manages auxiliary actuators like fan, pump, mixer, etc.
#include "Config.h"            // Global configuration constants (e.g., NUM_MOTORS)
#include <Arduino.h>           // Arduino core functions and types (pinMode, millis, digitalWrite, etc.)

// Main orchestrator of the embedded system. Handles setup, runtime control, and data flow.
class SystemCore {
public:
    // Constructor to initialize internal members (could also be used to preload configs)
    SystemCore();
    
    // Destructor to clean up dynamically allocated objects
    ~SystemCore();

    // Sets up all subsystems (sensors, motors, Modbus, etc.)
    void setup();

    // Main runtime loop. Should be called repeatedly from Arduino's loop()
    void loop();

    // Allows ModbusHandler to access private members like motors[] directly.
    // Useful for implementing indirect register callbacks.
    friend class ModbusHandler;

private:
    // --- Subsystems ---

    ModbusHandler modbus;               // Modbus RTU slave handler (interfaces with external master like Python GUI)

    TemperatureSensor airSensor;        // Ambient air temperature sensor (DS18B20 or similar)
    TemperatureSensor waterSensor;      // Water temperature sensor (same interface as above)

    TemperatureSensor* motorSensors[NUM_MOTORS]; // Array of pointers to per-motor temperature sensors

    Motor* motors[NUM_MOTORS];          // Array of pointers to core motor control objects

    DeviceManager deviceManager;        // Controls peripheral devices (fan, mixer, pump, etc.)

    uint64_t accumulated_ticks = 0;
    uint32_t last_overflow_snapshot = 0;
    uint16_t current_timer0_prescaler = 64;

    // --- Timekeeping ---

    // Custom millisecond counter (optionally extended to 64-bit for rollover-safe timing)
    uint64_t millisCustom();

    // Stores prescaler state for custom millis if using a timer overflow counter
    uint16_t prev_prescaler;
};

// Declares a global instance accessible throughout the codebase.
// Allows Modbus callbacks or interrupt handlers to refer to the central system state.
extern SystemCore systemCore;

================================================================================
File: include\TemperatureSensor.h
================================================================================


#pragma once  // Ensure the header is only included once during compilation

#include <OneWire.h>             // For communicating with 1-Wire devices like DS18B20
#include <DallasTemperature.h>   // High-level wrapper for 1-Wire temperature sensors
#include <Arduino.h>             // Core Arduino definitions and types

// Class to encapsulate a single DS18B20 temperature sensor
class TemperatureSensor {
private:
    OneWire oneWire;             // OneWire bus instance, bound to a specific pin
    DallasTemperature sensor;    // DallasTemperature library interface for reading sensor(s)
    
    uint16_t regTemp;            // Modbus register to store current temperature
    uint16_t regLowThreshold;    // Modbus register for minimum safe temperature
    uint16_t regHighThreshold;   // Modbus register for maximum safe temperature
    
    int16_t temperature;         // Last read temperature in 0.1°C precision (e.g., 254 = 25.4°C)
                                 // Changed from uint16_t to handle negative Celsius values
    uint8_t status;              // Encoded sensor status (e.g., 0=OK, 1=too low, 2=too high)
    uint64_t lastTemperatureRequest = 0; // Instance-specific timestamp

    uint32_t lastRequestTime;
    bool conversionPending;
public:
    // Constructor: specify GPIO pin and Modbus register mappings
    TemperatureSensor(uint8_t pin, uint16_t tempReg, uint16_t lowThresholdReg, uint16_t highThresholdReg);

    // Initializes OneWire and DallasTemperature libraries
    void begin();

    // Reads temperature from sensor and updates Modbus registers and status
    void update();

    // Returns latest temperature value in 0.1°C precision (e.g., 325 = 32.5°C)
    int16_t getTemperature() const;

    // Returns current status code
    uint8_t getStatus() const;

    // Read data from sensors (Take's a bit time so we need it to call before reading temps)
    void requestTemperatures(uint64_t now);

    void requestTemperaturesAsync(uint64_t now);
    bool isConversionComplete();
    void readTemperatureAsync();

};

================================================================================
File: lib\README
================================================================================


This directory is intended for project specific (private) libraries.
PlatformIO will compile them to static libraries and link into the executable file.

The source code of each library should be placed in a separate directory
("lib/your_library_name/[Code]").

For example, see the structure of the following example libraries `Foo` and `Bar`:

|--lib
|  |
|  |--Bar
|  |  |--docs
|  |  |--examples
|  |  |--src
|  |     |- Bar.c
|  |     |- Bar.h
|  |  |- library.json (optional. for custom build options, etc) https://docs.platformio.org/page/librarymanager/config.html
|  |
|  |--Foo
|  |  |- Foo.c
|  |  |- Foo.h
|  |
|  |- README --> THIS FILE
|
|- platformio.ini
|--src
   |- main.c

Example contents of `src/main.c` using Foo and Bar:
```
#include <Foo.h>
#include <Bar.h>

int main (void)
{
  ...
}

```

The PlatformIO Library Dependency Finder will find automatically dependent
libraries by scanning project source files.

More information about PlatformIO Library Dependency Finder
- https://docs.platformio.org/page/librarymanager/ldf.html


================================================================================
File: src\CurrentSensor.cpp
================================================================================

#include "CurrentSensor.h"
#include "ModbusHandler.h"
#include "Config.h"
#include "Globals.h"

CurrentSensor::CurrentSensor(uint8_t pin, uint16_t regAddr)
    : pin(pin), regAddr(regAddr), filteredValue(0),
      smoothingFactor(DEFAULT_SMOOTHING), lastSampleTime(0) {}

void CurrentSensor::begin() {
    pinMode(pin, INPUT);
    // Initial reading to start filter
    uint16_t raw = analogRead(pin);
    filteredValue = raw;
}

void CurrentSensor::update(uint64_t now) {
    if (now - lastSampleTime < SAMPLE_INTERVAL) return;
    
    lastSampleTime = now;
    uint16_t raw = analogRead(pin);
    
    // Exponential smoothing
    filteredValue = smoothingFactor * raw + (1 - smoothingFactor) * filteredValue;
    
    // Convert to mA (ACS712-5A specific conversion)
    uint16_t current = (filteredValue - 512) * 1000 / 66;
    
    // Update Modbus register
    modbusHandler->setIreg(regAddr, current);
}

uint16_t CurrentSensor::getCurrent() const {
    return (filteredValue - 512) * 1000 / 66;
}

void CurrentSensor::setSmoothingFactor(float factor) {
    smoothingFactor = constrain(factor, 0.0f, 1.0f);
}

================================================================================
File: src\DeviceManager.cpp
================================================================================


#include "DeviceManager.h"
#include "ModbusHandler.h"
#include "Config.h"
#include "Globals.h"

void DeviceManager::begin() {
    pinMode(FAN_PIN, OUTPUT);
    pinMode(MIXER_PIN, OUTPUT);
    pinMode(DISPENSER_PIN, OUTPUT);
    pinMode(PUMP_PIN, OUTPUT);

    // Optional: clear state
    digitalWrite(FAN_PIN, LOW);
    digitalWrite(MIXER_PIN, LOW);
    digitalWrite(DISPENSER_PIN, LOW);
    digitalWrite(PUMP_PIN, LOW);
}

void DeviceManager::update(const TemperatureSensor& airSensor, 
                           const TemperatureSensor& waterSensor, 
                           const Motor* const* motors) {
    // --- Fan logic ---
    uint16_t airTemp = airSensor.getTemperature();
    uint16_t airLow = modbusHandler->getHreg(ModbusReg::AIR_TEMP_LOW);
    uint16_t airHigh = modbusHandler->getHreg(ModbusReg::AIR_TEMP_HIGH);
    bool fanState = false;

    if (airTemp != 0xFFFF) {
        fanState = (airTemp >= airHigh) || (airTemp <= airLow);
    }
    controlFan(fanState);

    // --- Mixer logic ---
    uint16_t waterTemp = waterSensor.getTemperature();
    uint16_t waterLow = modbusHandler->getHreg(ModbusReg::WATER_TEMP_LOW);
    uint16_t waterHigh = modbusHandler->getHreg(ModbusReg::WATER_TEMP_HIGH);
    bool mixerState = false;

    if (waterTemp != 0xFFFF) {
        mixerState = (waterTemp >= waterHigh) || (waterTemp <= waterLow);
    }
    controlMixer(mixerState);

    // --- Dispenser logic ---
    bool dispenserState = (waterTemp != 0xFFFF && waterTemp >= waterHigh);
    controlDispenser(dispenserState);

    // --- Pump logic ---
    bool pumpState = false;
    for (int i = 0; i < NUM_MOTORS; i++) {
        if (motors[i]->getStatus() < 2 && 
            modbusHandler->getHreg(ModbusReg::DUTY_BASE + i) > 0) {
            pumpState = true;
            break;
        }
    }
    controlPump(pumpState);
}

// Device control methods with Modbus feedback

void DeviceManager::controlFan(bool state) {
    digitalWrite(FAN_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 0, state ? 1 : 0);
}

void DeviceManager::controlMixer(bool state) {
    digitalWrite(MIXER_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 1, state ? 1 : 0);
}

void DeviceManager::controlDispenser(bool state) {
    digitalWrite(DISPENSER_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 2, state ? 1 : 0);
}

void DeviceManager::controlPump(bool state) {
    digitalWrite(PUMP_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 3, state ? 1 : 0);
}

================================================================================
File: src\Globals.cpp
================================================================================


#include "Globals.h"

ModbusHandler* modbusHandler = nullptr;
DeviceManager* deviceManager = nullptr;
Motor** motors = nullptr;  // Changed from Motor* to Motor**

================================================================================
File: src\main.cpp
================================================================================


#include <Arduino.h>
#include <SystemCore.h>
#include "Config.h"
#include <avr/wdt.h>

SystemCore systemCore;

void setup() {
  systemCore.setup();
  // wdt_enable(WDTO_2S);
}

void loop() {
  // wdt_enable(WDTO_2S);
  systemCore.loop();
}

================================================================================
File: src\ModbusHandler.cpp
================================================================================


#include "ModbusHandler.h"
#include "Motor.h"
#include "DeviceManager.h"
#include "Config.h"
#include "Globals.h"

ModbusHandler::ModbusHandler(HardwareSerial& portRef, uint8_t slaveRef)
    : port(portRef), slaveID(slaveRef) {}

void ModbusHandler::begin(unsigned long baudrate) {
    port.begin(baudrate);  // For logging and Modbus

    // Begin with explicit parity (even) for validation
    if (!ModbusRTUServer.begin(slaveID, baudrate, SERIAL_8E1)) {
        while (1);
    }

    // Configure ranges (larger for safety)
    ModbusRTUServer.configureHoldingRegisters(0, 1000);
    ModbusRTUServer.configureInputRegisters(0, 1000);

    // Init registers
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::START_REG_ADDR, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW + 1, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW + 2, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW + 3, 0);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::MOTOR_TEMP_CRIT, TEMP_CRITICAL);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::MOTOR_CURR_CRIT, CURR_CRITICAL);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::AIR_TEMP_LOW, TEMP_WARNING);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::AIR_TEMP_HIGH, TEMP_CRITICAL);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::WATER_TEMP_LOW, TEMP_WARNING);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::WATER_TEMP_HIGH, TEMP_CRITICAL);

    // Init duty and freq shadows and registers
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        ModbusRTUServer.holdingRegisterWrite(ModbusReg::DUTY_BASE + i, 0);
        dutyShadows[i] = 0;
        // ModbusRTUServer.holdingRegisterWrite(ModbusReg::FREQ_BASE + i, 1000);
        // freqShadows[i] = 1000;
    }
    memset(deviceShadows, 0, sizeof(deviceShadows));
    startShadow = 0;

}

void ModbusHandler::task() {
    static uint8_t errorCount = 0;
    
    int pollResult = ModbusRTUServer.poll();
    if (pollResult == -1) {
        if (++errorCount > 10) {
            // Reset Modbus state after 10 errors
            ModbusRTUServer.begin(slaveID, BAUDRATE, SERIAL_8E1);
            errorCount = 0;
        }
    } else {
        errorCount = 0;
    }
    if (!port.available()) return;

    // int pollResult = ModbusRTUServer.poll();
    // if (pollResult == -1) {
    //     // Error handling (e.g., frame/CRC error); increment counter or log
    // }

    // Check for changes in holding registers (reactive handling)
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        uint16_t dutyVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::DUTY_BASE + i);
        if (dutyVal != dutyShadows[i]) {
            handleMotorWrite(ModbusReg::DUTY_BASE + i, dutyVal);
            dutyShadows[i] = dutyVal;
        }
        // uint16_t freqVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::FREQ_BASE + i);
        // if (freqVal != freqShadows[i]) {
            // handleMotorWrite(ModbusReg::FREQ_BASE + i, freqVal);
            // freqShadows[i] = freqVal;
        // }
    }
    for (uint8_t i = 0; i < 4; i++) {
        uint16_t devVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::DEV_STATUS_BASE + i);
        if (devVal != deviceShadows[i]) {
            handleDeviceWrite(ModbusReg::DEV_STATUS_BASE + i, devVal);
            deviceShadows[i] = devVal;
        }
    }
    uint16_t startVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::START_REG_ADDR);
    if (startVal != startShadow) {
        handleSystemWrite(ModbusReg::START_REG_ADDR, startVal);
        startShadow = startVal;
    }
}

uint16_t ModbusHandler::getHreg(uint16_t addr) {
    return ModbusRTUServer.holdingRegisterRead(addr);
}

uint16_t ModbusHandler::getIreg(uint16_t addr) {
    return ModbusRTUServer.inputRegisterRead(addr);
}

void ModbusHandler::setHreg(uint16_t addr, uint16_t value) {
    ModbusRTUServer.holdingRegisterWrite(addr, value);
}

void ModbusHandler::setIreg(uint16_t addr, uint16_t value) {
    ModbusRTUServer.inputRegisterWrite(addr, value);
}

void ModbusHandler::handleMotorWrite(uint16_t addr, uint16_t val) {  // Changed parameter type to uint16_t
    if (addr >= ModbusReg::DUTY_BASE &&
        addr < ModbusReg::DUTY_BASE + NUM_MOTORS) {
        uint8_t id = addr - ModbusReg::DUTY_BASE;
        motors[id]->setDuty(val);
    } 
    else if (addr == ModbusReg::GLOBAL_FREQ) {
        globalFreqShadow = val;
        // PWMController::setGlobalFrequency(val);
        motors[1]->setFrequency(val);
    }
    // else if (addr >= ModbusReg::FREQ_BASE &&
            //    addr < ModbusReg::FREQ_BASE + NUM_MOTORS) {
        // uint8_t id = addr - ModbusReg::FREQ_BASE;
        // motors[id]->setFrequency(val);
    // }
}

void ModbusHandler::handleDeviceWrite(int addr, uint16_t val) {
    if (addr == ModbusReg::FAN_REG) deviceManager->controlFan(val > 0);
    else if (addr == ModbusReg::MIXER_REG) deviceManager->controlMixer(val > 0);
    else if (addr == ModbusReg::DISPENSER_REG) deviceManager->controlDispenser(val > 0);
    else if (addr == ModbusReg::PUMP_REG) deviceManager->controlPump(val > 0);
}

void ModbusHandler::handleSystemWrite(int addr, uint16_t val) {
    if (val == 0) {
        for (int i = 0; i < NUM_MOTORS; i++) {
            motors[i]->setDuty(0);
        }
        deviceManager->controlFan(false);
        deviceManager->controlMixer(false);
        deviceManager->controlDispenser(false);
        deviceManager->controlPump(false);
    }
}

================================================================================
File: src\Motor.cpp
================================================================================

#include "Motor.h"
#include "PWMController.h"
#include "ModbusHandler.h"
#include "Config.h"
#include "Globals.h"

Motor::Motor(uint8_t id, uint8_t pwmPin, uint8_t currentPin, 
             TemperatureSensor* tempSensor, ModbusHandler& modbus)
    : id(id), pwmPin(pwmPin), 
      currentSensor(currentPin, ModbusReg::CURR_BASE + id),  // Initialize CurrentSensor
      tempSensor(tempSensor), modbusHandler(modbus),
      dutyCycle(0), status(0) {}

void Motor::begin() {
    pinMode(pwmPin, OUTPUT);
    currentSensor.begin();  // Initialize current sensor
    
    // PWMController::setFrequency(pwmPin, 1000);
    PWMController::setGlobalFrequency(1000);
    PWMController::setDutyCycle(pwmPin, 0);
}

void Motor::update(uint64_t now) {
    currentSensor.update(now);  // Update current reading
    
    int16_t temp = tempSensor->getTemperature();
    modbusHandler.setIreg(ModbusReg::TEMP_BASE + id, static_cast<uint16_t>(temp));

    uint8_t tempStatus = tempSensor->getStatus();
    uint16_t tempCritThreshold = modbusHandler.getHreg(ModbusReg::MOTOR_TEMP_CRIT);
    uint16_t currCritThreshold = modbusHandler.getHreg(ModbusReg::MOTOR_CURR_CRIT);
    uint16_t current = currentSensor.getCurrent();  // Get current from sensor

    if (tempStatus == 3) {
        status = 3;
        setDuty(0);
    } else if (temp >= static_cast<int16_t>(tempCritThreshold) || current >= currCritThreshold) {
        status = 2;
        setDuty(0);
    } else if (tempStatus > 0) {
        status = 1;
    } else {
        status = 0;
    }

    modbusHandler.setIreg(ModbusReg::STATUS_BASE + id, status);
}


void Motor::setDuty(uint16_t duty) {
    dutyCycle = (duty > 1000) ? 1000 : duty;  // Clamp to 1000
    PWMController::setDutyCycle(pwmPin, dutyCycle);
}

void Motor::setFrequency(uint32_t freq) {
    PWMController::setGlobalFrequency(freq);
}

uint8_t Motor::getStatus() const {
    return status;
}

================================================================================
File: src\PWMController.cpp
================================================================================

// PWMController.cpp
#include "PWMController.h"
#include "Config.h"     // Contains MIN_PWM_FREQ and MAX_PWM_FREQ
#include <Arduino.h>
#include <avr/io.h>     // Direct access to AVR timer registers

// Initialize all timers (Timer0–Timer5) in PWM mode
void PWMController::initialize() {
    // Ensure pins are outputs
    // pinMode(13, OUTPUT); // PB7: OC1C (Timer1) — repurposed from OC0A
    // pinMode(4,  OUTPUT); // PG5: OC0B (Timer0)

    // ---------------- Timer 0: Pin 4 (OC0B) with OCR0A as TOP ----------------
    // Fast PWM with OCR0A as TOP (WGM02:0 = 7). OC0B enabled, OC0A disconnected.
    TCCR0A = _BV(WGM00) | _BV(WGM01) | _BV(COM0B1);
    TCCR0B = _BV(WGM02) | _BV(CS00); // prescaler = /1
    OCR0A  = 0xFF;
    OCR0B  = 0x00;

    // ---------------- Timer 1: Pins 11 (OC1A), 12 (OC1B), 13 (OC1C) ----------------
    // Mode 14 Fast PWM, TOP=ICR1
    TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(COM1C1) | _BV(WGM11);
    TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // prescaler = /1
    ICR1   = 2000;

    // ---------------- Timer 2: Pins 9,10 (OC2A,OC2B) ----------------
    // Fast PWM, fixed prescaler choices
    TCCR2A = _BV(WGM20) | _BV(WGM21) | _BV(COM2A1) | _BV(COM2B1);
    TCCR2B = _BV(CS20);
    OCR2A  = 0xFF;
    OCR2B  = 0x00;

    // ---------------- Timer 3: Pins 5,2,3 (OC3A/OC3B/OC3C) ----------------
    TCCR3A = _BV(COM3A1) | _BV(COM3B1) | _BV(WGM31);
    TCCR3B = _BV(WGM33) | _BV(WGM32) | _BV(CS30);
    ICR3   = 2000;

    // ---------------- Timer 4: Pins 6,7,8 (OC4A/OC4B/OC4C) ----------------
    TCCR4A = _BV(COM4A1) | _BV(COM4B1) | _BV(WGM41);
    TCCR4B = _BV(WGM43) | _BV(WGM42) | _BV(CS40);
    ICR4   = 2000;

    // ---------------- Timer 5: Pins 46 (OC5A), 45 (OC5B), 44 (OC5C) ----------------
    TCCR5A = _BV(COM5A1) | _BV(COM5B1) | _BV(WGM51);               // Fast PWM, Mode 14
    TCCR5B = _BV(WGM53) | _BV(WGM52) | _BV(CS50);                  // Prescaler = /1
    ICR5   = 2000;
}

// Default global frequency
uint32_t PWMController::currentGlobalFreq = 1000;
void PWMController::setGlobalFrequency(uint32_t freq) {
    currentGlobalFreq = constrain(freq, MIN_PWM_FREQ, MAX_PWM_FREQ);

    // Timer 0 (8-bit): Pin 4


    // Timer 2 (8-bit): Pins 9, 10 
    if (freq >= 30000)       TCCR2B = (TCCR2B & 0xF8) | 0x01;
    else if (freq >= 20000)  TCCR2B = (TCCR2B & 0xF8) | 0x02;
    else if (freq >= 10000)  TCCR2B = (TCCR2B & 0xF8) | 0x03;
    else if (freq >= 5000)   TCCR2B = (TCCR2B & 0xF8) | 0x04;
    else if (freq >= 1000)   TCCR2B = (TCCR2B & 0xF8) | 0x05;
    else if (freq >= 500)    TCCR2B = (TCCR2B & 0xF8) | 0x06;
    else                     TCCR2B = (TCCR2B & 0xF8) | 0x07;

    // Timers 1, 3, 4, 5 (16-bit): pins 2, 3, 5, 6, 7, 8, 11, 12...is switched from Timer 2 to Timer 1 channel C in initialization)
    // Let timebase code handle Timer1 prescaler to preserve time accounting.
    TCCR1B = (TCCR1B & 0xF8) | 0x01;
    TCCR3B = (TCCR3B & 0xF8) | 0x01;
    TCCR4B = (TCCR4B & 0xF8) | 0x01;
    TCCR5B = (TCCR5B & 0xF8) | 0x01;

    // f = F_CPU / (prescaler * (1 + TOP)), with prescaler = 1:
    uint32_t top = (F_CPU / (1UL * freq));
    if (top > 0) top -= 1;
    if (top < 1) top = 1;           // avoid TOP=0
    if (top > 65535UL) top = 65535; // with prescaler=1, this caps at ~244 Hz

    // Program Timer1 TOP via timebase API so timebase snapshots prior epoch
    ICR1 = uint16_t(top);
    ICR3 = uint16_t(top);
    ICR4 = uint16_t(top);
    ICR5 = uint16_t(top);
}

// ... rest of PWMController implementation remains unchanged ...
// (functions to set duty for channels, map pins to timers, etc.)


// Set PWM frequency for the given pin
// void PWMController::setFrequency(uint8_t pin, uint32_t freq) {
//     if (freq == 0) return;
//     freq = constrain(freq, MIN_PWM_FREQ, MAX_PWM_FREQ);  // Safety clamp

//     // -------- Timer 0 (Fast PWM, OCR0A as TOP): Pin 4 only; choose prescaler + TOP --------
//     if (pin == 4) {
//         // Try prescalers in ascending order to maximize TOP while staying within 8-bit limit.
//         const uint16_t prescVals[5] = {1, 8, 64, 256, 1024};
//         const uint8_t  csBits[5]    = {0x01, 0x02, 0x03, 0x04, 0x05};

//         uint8_t chosenCS = csBits[4]; // default to largest prescaler
//         uint8_t top = 255;

//         for (uint8_t i = 0; i < 5; ++i) {
//             uint32_t calcTop = (F_CPU / (prescVals[i] * (uint32_t)freq));
//             if (calcTop == 0) continue;
//             calcTop -= 1;
//             if (calcTop >= 2 && calcTop <= 255) { // keep at least 2 for non-trivial duty resolution
//                 chosenCS = csBits[i];
//                 top = (uint8_t)calcTop;
//                 break; // first fit => largest TOP in range
//             }
//         }

//         // Program prescaler (preserve WGM02) and TOP
//         TCCR0B = (TCCR0B & 0xF8) | chosenCS; // keep upper bits incl. WGM02
//         OCR0A  = top;                        // new TOP for Timer0
//         return;
//     }

//     // -------- Timer 2 (8-bit): Pins 9, 10 (unchanged behavior) --------
//     else if (pin == 9 || pin == 10) {
//         if (freq >= 30000)       TCCR2B = (TCCR2B & 0xF8) | 0x01;
//         else if (freq >= 8000)   TCCR2B = (TCCR2B & 0xF8) | 0x02;
//         else if (freq >= 2000)   TCCR2B = (TCCR2B & 0xF8) | 0x03;
//         else if (freq >= 1000)   TCCR2B = (TCCR2B & 0xF8) | 0x04;
//         else if (freq >= 500)    TCCR2B = (TCCR2B & 0xF8) | 0x05;
//         else if (freq >= 250)    TCCR2B = (TCCR2B & 0xF8) | 0x06;
//         else                     TCCR2B = (TCCR2B & 0xF8) | 0x07;
//         return;
//     }

//     // -------- 16-bit timers (1,3,4,5): prescaler = 1; set ICRx as TOP --------
//     else {
//         // f = F_CPU / (N * (1 + TOP)), with N = 1
//         uint32_t top = (F_CPU / (1UL * freq));
//         if (top > 0) top -= 1;
//         if (top < 1) top = 1;           // avoid TOP=0
//         if (top > 65535UL) top = 65535; // with N=1, this caps at ~244 Hz

//         switch (pin) {
//             case 11: case 12: case 13:
//                 // Ensure prescaler = 1 (preserve WGM bits)
//                 TCCR1B = (TCCR1B & 0xF8) | 0x01;
//                 ICR1 = (uint16_t)top;
//                 break;
//             case 5: case 2: case 3:
//                 TCCR3B = (TCCR3B & 0xF8) | 0x01;
//                 ICR3 = (uint16_t)top;
//                 break;
//             case 6: case 7: case 8:
//                 TCCR4B = (TCCR4B & 0xF8) | 0x01;
//                 ICR4 = (uint16_t)top;
//                 break;
//             case 46: case 45: case 44:
//                 TCCR5B = (TCCR5B & 0xF8) | 0x01;
//                 ICR5 = (uint16_t)top;
//                 break;
//         }
//         return;
//     }
// }

// Set PWM duty cycle (0–1000) for the given pin
void PWMController::setDutyCycle(uint8_t pin, uint16_t duty) {
    noInterrupts();
    duty = constrain(duty, 0, 1000);  // per-mille (0–1000)
    uint16_t ocrValue = 0;

    switch (pin) {
        // --- Timer1 (ICR1 as TOP) ---
        case 11: ocrValue = (uint32_t)duty * ICR1 / 1000UL; OCR1A = ocrValue; break;
        case 12: ocrValue = (uint32_t)duty * ICR1 / 1000UL; OCR1B = ocrValue; break;
        case 13: ocrValue = (uint32_t)duty * ICR1 / 1000UL; OCR1C = ocrValue; break;

        // --- Timer3 (ICR3 as TOP) ---
        case 5:  ocrValue = (uint32_t)duty * ICR3 / 1000UL; OCR3A = ocrValue; break;
        case 2:  ocrValue = (uint32_t)duty * ICR3 / 1000UL; OCR3B = ocrValue; break;
        case 3:  ocrValue = (uint32_t)duty * ICR3 / 1000UL; OCR3C = ocrValue; break;

        // --- Timer4 (ICR4 as TOP) ---
        case 6:  ocrValue = (uint32_t)duty * ICR4 / 1000UL; OCR4A = ocrValue; break;
        case 7:  ocrValue = (uint32_t)duty * ICR4 / 1000UL; OCR4B = ocrValue; break;
        case 8:  ocrValue = (uint32_t)duty * ICR4 / 1000UL; OCR4C = ocrValue; break;

        // --- Timer2 (8-bit, TOP=255) ---
        case 9:  ocrValue = (uint32_t)duty * 255 / 1000UL; OCR2B = ocrValue; break;
        case 10: ocrValue = (uint32_t)duty * 255 / 1000UL; OCR2A = ocrValue; break;

        // --- Timer0 (Fast PWM, TOP=OCR0A) ---
        case 4:  ocrValue = (uint32_t)duty * OCR0A / 1000UL; OCR0B = ocrValue; break;

        // --- Timer5 (ICR5 as TOP) ---
        case 46: ocrValue = (uint32_t)duty * ICR5 / 1000UL; OCR5A = ocrValue; break;
        case 45: ocrValue = (uint32_t)duty * ICR5 / 1000UL; OCR5B = ocrValue; break;
        case 44: ocrValue = (uint32_t)duty * ICR5 / 1000UL; OCR5C = ocrValue; break;
    }
    interrupts();
}


================================================================================
File: src\SystemCore.cpp
================================================================================


#include "Globals.h"
#include "SystemCore.h"
#include "Config.h"
#include "PWMController.h"   // Add this line

SystemCore::SystemCore()
    : modbus(Serial, SLAVE_ID),
      airSensor(AIR_TEMP_PIN, 
                ModbusReg::AIR_TEMP_REG,
                ModbusReg::AIR_TEMP_LOW,
                ModbusReg::AIR_TEMP_HIGH),
      waterSensor(WATER_TEMP_PIN, 
                  ModbusReg::WATER_TEMP_REG,
                  ModbusReg::WATER_TEMP_LOW,
                  ModbusReg::WATER_TEMP_HIGH),
      prev_prescaler(0) {
    ::modbusHandler = &modbus;
    ::deviceManager = &deviceManager;
    ::motors = this->motors;  // Update global pointer to motor array

    // Initialize motor sensors with dynamic allocation
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motorSensors[i] = new TemperatureSensor(
            TEMP_PINS[i], 
            ModbusReg::TEMP_BASE + i,
            ModbusReg::MOTOR_TEMP_CRIT,
            0  // High threshold not used for motors
        );
    }
    
    // Initialize motors with dynamic allocation
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motors[i] = new Motor(
            i, 
            PWM_PINS[i], 
            CURRENT_PINS[i], 
            motorSensors[i],  // Pass pointer to sensor
            this->modbus
        );
    }
}

SystemCore::~SystemCore() {
    // Clean up dynamically allocated objects
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        delete motorSensors[i];
        delete motors[i];
    }
}

void SystemCore::setup() {
    modbus.begin();
    
    // Initialize sensors
    airSensor.begin();
    waterSensor.begin();
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motorSensors[i]->begin();  // Pointer access
    }
    
    // Initialize motors
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motors[i]->begin();  // Pointer access
    }
    
    PWMController::initialize();
    // Initialize devices
    deviceManager.begin();
}

void SystemCore::loop() {
    static uint8_t currentSensor = 0;

    
    static uint64_t lastMotorUpdate = 0;
    static uint64_t lastTempUpdate = 0;
    uint64_t now = millisCustom();

        modbus.setIreg(ModbusReg::TIME_LOW, uint16_t(now & 0xFFFF));
        modbus.setIreg(ModbusReg::TIME_LOW + 1, uint16_t((now >> 16) & 0xFFFF));
        modbus.setIreg(ModbusReg::TIME_LOW + 2, uint16_t((now >> 32) & 0xFFFF));
        modbus.setIreg(ModbusReg::TIME_LOW + 3, uint16_t((now >> 48) & 0xFFFF));

    modbus.task();
    
    // Update motor status every 500ms
    if (now - lastMotorUpdate >= 100) {
        lastMotorUpdate = now;
        for (uint8_t i = 0; i < NUM_MOTORS; i += 3) { // Process 2 motors per cycle
            if (i < NUM_MOTORS) motors[i]->update(now);
            if (i+1 < NUM_MOTORS) motors[i+1]->update(now);
            if (i+2 < NUM_MOTORS) motors[i+2]->update(now);
            modbus.task(); // Handle Modbus between batches
        }
    }

    // Update temperature and devices every 1000ms
    if (now - lastTempUpdate >= 1000) {
        lastTempUpdate = now;

        // Request temperatures first
        for (uint8_t i = 0; i < NUM_MOTORS; i++) {
            motorSensors[i]->requestTemperaturesAsync(now);  // Pointer access
        }

        // Then update all temperature readings
        for (uint8_t i = 0; i < NUM_MOTORS; i++) {
            motorSensors[i]->update();  // Pointer access
        }

        airSensor.update();
        waterSensor.update();
        
        // Update devices (pass pointer to motor array)
        deviceManager.update(airSensor, waterSensor, motors);
        
        // Update timestamp register
    }
}

uint64_t SystemCore::millisCustom() {
    extern volatile unsigned long timer0_overflow_count;
    
    uint8_t tcnt0_snapshot;
    uint32_t overflow_snapshot;

    // Determine the new prescaler directly from the register
    uint8_t prescaler_bits = TCCR0B & 0x07;
    uint16_t new_prescaler;
    switch (prescaler_bits) {
        case 1: new_prescaler = 1; break;
        case 2: new_prescaler = 8; break;
        case 3: new_prescaler = 64; break;
        case 4: new_prescaler = 256; break;
        case 5: new_prescaler = 1024; break;
        default: new_prescaler = 64; break;
    }

    noInterrupts();
    tcnt0_snapshot = TCNT0;
    overflow_snapshot = timer0_overflow_count;
    // This check is crucial to catch an overflow that happens right as we read the registers
    if ((TIFR0 & _BV(TOV0)) && (tcnt0_snapshot < 255)) {
        overflow_snapshot++;
    }
    interrupts();

    // The core logic: If the prescaler has changed, we finalize the time
    // accumulated with the OLD prescaler and add it to our master accumulator.
    if (new_prescaler != current_timer0_prescaler) {
        // Calculate overflows since last check and convert to ticks using the OLD prescaler
        uint32_t overflows_since_last = overflow_snapshot - last_overflow_snapshot;
        accumulated_ticks += (uint64_t)overflows_since_last * 256 * current_timer0_prescaler;
        
        // Update the last snapshot and the current prescaler for the next run
        last_overflow_snapshot = overflow_snapshot;
        current_timer0_prescaler = new_prescaler;
    }

    // Calculate total ticks: the master accumulator plus the ticks in the current cycle
    uint64_t overflows_since_last = overflow_snapshot - last_overflow_snapshot;
    uint64_t ticks_since_last_update = (overflows_since_last * 256 + tcnt0_snapshot) * current_timer0_prescaler;
    uint64_t total_ticks = accumulated_ticks + ticks_since_last_update;


    // Convert total CPU ticks to milliseconds using integer math
    return total_ticks / (F_CPU / 1000UL);
}

================================================================================
File: src\TemperatureSensor.cpp
================================================================================


#include "TemperatureSensor.h"
#include "ModbusHandler.h"
#include "Config.h"
#include "Globals.h"


// Constructor: initializes sensor objects and register mappings
TemperatureSensor::TemperatureSensor(uint8_t pin, uint16_t tempReg, 
                     uint16_t lowThresholdReg, uint16_t highThresholdReg) 
    : oneWire(pin),                // Initialize OneWire bus on specified pin
      sensor(&oneWire),           // Bind DallasTemperature instance to OneWire bus
      regTemp(tempReg),           // Register for current temperature value
      regLowThreshold(lowThresholdReg),   // Register for low temperature threshold
      regHighThreshold(highThresholdReg), // Register for high temperature threshold
      temperature(0),             // Initialize temperature to 0
      status(0) {}                // Initial status: normal

// Initializes the temperature sensor hardware
void TemperatureSensor::begin() {
    sensor.begin();               // Initialize DallasTemperature library
    sensor.setResolution(10);     // Set sensor resolution (11 bits = 0.125°C precision)
    sensor.setWaitForConversion(false);
}

void TemperatureSensor::requestTemperatures(uint64_t now) {
    if (now - lastTemperatureRequest > 1000) {
        sensor.requestTemperatures(); // Trigger temperature reading from DS18B20
        lastTemperatureRequest = now;
    }
}

void TemperatureSensor::requestTemperaturesAsync(uint64_t now) {
    if (!conversionPending && (now - lastRequestTime > 1000)) {
        sensor.requestTemperatures();
        conversionPending = true;
        lastRequestTime = now;
    }
}

bool TemperatureSensor::isConversionComplete() {
    if (conversionPending) {
        conversionPending = !sensor.isConversionComplete();
        return !conversionPending;
    }
    return false;
}

// Reads temperature, checks thresholds, and updates Modbus registers
void TemperatureSensor::update() {
    if (conversionPending && sensor.isConversionComplete()) {
        float tempC = sensor.getTempCByIndex(0); // Read the first sensor on the bus
    
        if (tempC == DEVICE_DISCONNECTED_C) {
            // Handle sensor disconnect case
            temperature = -32768;     // INT16_MIN sentinel value to indicate error
            status = 3;               // Status code for disconnected
        } else {
            // Convert temperature to centi-degrees (e.g., 25.34°C → 2534)
            temperature = static_cast<int16_t>(tempC * 100); 
            
            // Read threshold values from holding registers
            uint16_t lowThreshold = modbusHandler->getHreg(regLowThreshold);
            uint16_t highThreshold = modbusHandler->getHreg(regHighThreshold);

            // Compare and classify temperature status
            if (temperature >= static_cast<int16_t>(highThreshold))
                status = 2; // Temperature above upper limit
            else if (temperature <= static_cast<int16_t>(lowThreshold))
                status = 1; // Temperature below lower limit
            else
                status = 0; // Temperature within acceptable range
        }

        // Write temperature to input register (read-only from master perspective)
        modbusHandler->setIreg(regTemp, static_cast<uint16_t>(temperature));
        // Note: If temperature is negative, casting to uint16_t will wrap around,
        // which may need special handling on Modbus master side.
        conversionPending = false;
    }
}

// Getter: returns raw centi-degree temperature value (can be negative)
// int16_t TemperatureSensor::getTemperature() const {
//     if (temperature < 0) {
//         return 0;
//     }
//     return temperature;
// }
int16_t TemperatureSensor::getTemperature() const {
    return temperature;
}

// Getter: returns current status flag (0=OK, 1=Low, 2=High, 3=Disconnected)
uint8_t TemperatureSensor::getStatus() const {
    return status;
}
