# PlatformIO Project Files


================================================================================
File: platformio.ini
================================================================================

; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

[env:megaatmega2560]
build_flags = 
	-DESERIAL_RX_BUFFER_SIZE=256
	-DESERIAL_TX_BUFFER_SIZE=256
platform = atmelavr
board = megaatmega2560
framework = arduino
monitor_speed = 115200 
lib_deps = 
	milesburton/DallasTemperature@^3.9.0
	PaulStoffregen/OneWire@^2.3.7
	arduino-libraries/ArduinoModbus@^1.0.9
	arduino-libraries/ArduinoRS485@^1.1.0



================================================================================
File: platformio_project.txt
================================================================================



================================================================================
File: qwen-cpp-txt.py
================================================================================

import os
import argparse
from pathlib import Path

def combine_platformio_files(root_dir, output_file, exclude_dirs=None, exclude_extensions=None):
    """
    Combines common PlatformIO project files into a single text file with clear separation.
    
    Args:
        root_dir (str): Root directory to search for files
        output_file (str): Output text file path
        exclude_dirs (list): List of directory names to exclude
        exclude_extensions (list): List of file extensions to exclude
    """
    if exclude_dirs is None:
        exclude_dirs = ['.git', '.svn', '.pio', '.vscode', 'lib_deps']
    
    if exclude_extensions is None:
        exclude_extensions = ['.png', '.jpg', '.jpeg', '.gif', '.ico', '.bin', '.hex', '.elf', '.o', '.a', '.so', '.dll', '.exe']
    
    # Common PlatformIO file extensions and names to include
    include_extensions = [
        '.py', '.ini', '.txt', '.md', '.yaml', '.yml', '.json', '.xml', 
        '.cpp', '.c', '.h', '.hpp', '.ino', '.S', '.ld', '.cfg'
    ]
    
    include_names = [
        'platformio.ini', 'README', 'README.md', 'LICENSE', 'library.json', 
        'library.properties', 'keywords.txt', 'platform.txt', 'boards.txt'
    ]
    
    with open(output_file, 'w', encoding='utf-8') as outfile:
        outfile.write("# PlatformIO Project Files\n\n")
        
        # Use rglob to recursively find all files
        for file_path in Path(root_dir).rglob("*"):
            # Skip if it's a directory
            if file_path.is_dir():
                continue
                
            # Skip excluded directories
            if any(excluded in file_path.parts for excluded in exclude_dirs):
                continue
                
            # Skip excluded extensions
            if file_path.suffix.lower() in exclude_extensions:
                continue
                
            # Include files with specific extensions or names
            if (file_path.suffix.lower() in include_extensions or 
                file_path.name in include_names or
                file_path.name.lower().startswith('readme')):
                
                relative_path = file_path.relative_to(root_dir)
                try:
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        
                    # Write clear file separation
                    outfile.write(f"\n{'='*80}\n")
                    outfile.write(f"File: {relative_path}\n")
                    outfile.write(f"{'='*80}\n\n")
                    outfile.write(content)
                    outfile.write("\n")
                    
                except UnicodeDecodeError:
                    # Handle binary files that might have slipped through
                    outfile.write(f"\n{'='*80}\n")
                    outfile.write(f"File: {relative_path}\n")
                    outfile.write(f"{'='*80}\n")
                    outfile.write("[Binary file - content not included]\n\n")
                except Exception as e:
                    print(f"Warning: Could not read {relative_path}: {e}")

def main():
    parser = argparse.ArgumentParser(description="Combine PlatformIO project files into a single text file")
    parser.add_argument("project_dir", help="PlatformIO project directory path")
    parser.add_argument("-o", "--output", default="platformio_project.txt", 
                        help="Output file name (default: platformio_project.txt)")
    parser.add_argument("-e", "--exclude", nargs='*', default=None,
                        help="Additional directories to exclude")
    parser.add_argument("--exclude-ext", nargs='*', default=None,
                        help="Additional file extensions to exclude")
    
    args = parser.parse_args()
    
    # Prepare exclusion list
    exclude_dirs = ['.git', '.pio', '.vscode', '.svn']
    if args.exclude:
        exclude_dirs.extend(args.exclude)
        
    exclude_ext = ['.png', '.jpg', '.jpeg', '.gif', '.ico', '.bin', '.hex']
    if args.exclude_ext:
        exclude_ext.extend(args.exclude_ext)
    
    # Verify project directory exists
    if not os.path.isdir(args.project_dir):
        print(f"Error: Directory '{args.project_dir}' does not exist")
        return
    
    # Combine files
    combine_platformio_files(args.project_dir, args.output, exclude_dirs, exclude_ext)
    print(f"Combined PlatformIO files saved to: {args.output}")

if __name__ == "__main__":
    main()

================================================================================
File: include\Config.h
================================================================================

#pragma once
#include <Arduino.h>  // Needed for pin constants


// Error codes
enum ErrorCode {
    ERR_NO_ERROR = 0,
    ERR_TEMP_LOW = 1,
    ERR_TEMP_HIGH = 2, 
    ERR_SENSOR_DISCONNECTED = 3,
    ERR_OVERCURRENT = 4,
    ERR_MODBUS_CRC_FAIL = 5,
    ERR_MODBUS_TIMEOUT = 6
};

// Serial port configuration
constexpr uint32_t BAUDRATE = 115200;

// -------------------------
// Pin Configuration
// -------------------------

// Motor control PWM output pins (software/hardware PWM)
constexpr uint8_t PWM_PINS[15] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 44, 45, 46};
constexpr uint8_t SLAVE_ID = 1;

// Motor current sensor analog input pins (ACS712 or similar)
constexpr uint8_t CURRENT_PINS[15] = {A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14};

// Motor temperature DS18B20 sensor digital input pins
constexpr uint8_t TEMP_PINS[15] = {22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36};

// System-wide sensors (also digital pins)
constexpr uint8_t WATER_TEMP_PIN = 20;  // ⚠️ Also I2C SDA
constexpr uint8_t AIR_TEMP_PIN = 21;    // ⚠️ Also I2C SCL

// Output control pins for actuators
constexpr uint8_t FAN_PIN = 40;
constexpr uint8_t MIXER_PIN = 41;
constexpr uint8_t DISPENSER_PIN = 42;
constexpr uint8_t PUMP_PIN = 43;

// -------------------------
// Modbus Register Map
// -------------------------
namespace ModbusReg {

    // --- Motor Parameters ---
    // Holding Registers (writeable by master)
    constexpr uint16_t DUTY_BASE = 0;      // Holding: [0–14] — duty cycle control
    constexpr uint16_t FREQ_BASE = 100;    // Holding: [100–114] — frequency control

    // Input Registers (read-only to master)
    constexpr uint16_t CURR_BASE = 200;    // Input: [200–214] — motor current values
    constexpr uint16_t TEMP_BASE = 300;    // Input: [300–314] — motor temperature values
    constexpr uint16_t STATUS_BASE = 400;  // Input: [400–414] — motor status (e.g. overtemp, error)

    // Thresholds (Holding registers, writeable by master)
    constexpr uint16_t MOTOR_TEMP_CRIT = 500;
    constexpr uint16_t MOTOR_CURR_CRIT = 501;

    // --- System Parameters ---
    constexpr uint16_t START_REG_ADDR = 900;
    constexpr uint16_t TIME_LOW = 901;

    // Air Temp
    constexpr uint16_t AIR_TEMP_REG = 920;
    constexpr uint16_t AIR_TEMP_LOW = 921;
    constexpr uint16_t AIR_TEMP_HIGH = 922;

    // Water Temp
    constexpr uint16_t WATER_TEMP_REG = 930;
    constexpr uint16_t WATER_TEMP_LOW = 931;
    constexpr uint16_t WATER_TEMP_HIGH = 932;

    // --- Device States ---
    constexpr uint16_t DEV_STATUS_BASE = 911;
    constexpr uint16_t FAN_REG = 911;
    constexpr uint16_t MIXER_REG = 912;
    constexpr uint16_t DISPENSER_REG = 913;
    constexpr uint16_t PUMP_REG = 914;
}

// -------------------------
// Safety & Operational Limits
// -------------------------

constexpr uint8_t NUM_MOTORS = 15;

// Temperature values scaled (e.g., 5000 = 50.00°C if using hundredths of °C)
constexpr uint16_t TEMP_WARNING  = 5000;
constexpr uint16_t TEMP_CRITICAL = 6000;
constexpr uint16_t CURR_CRITICAL = 900;     // mA or raw sensor units

// PWM frequency range (Hz)
constexpr uint16_t MIN_PWM_FREQ = 100;
constexpr uint16_t MAX_PWM_FREQ = 30000;


================================================================================
File: include\DeviceManager.h
================================================================================

#pragma once
#include "TemperatureSensor.h"
#include "Motor.h"

class DeviceManager {
public:
    void begin();

    // Changed third parameter type to const Motor* const*
    void update(const TemperatureSensor& airSensor, 
                const TemperatureSensor& waterSensor, 
                const Motor* const* motors); // Fixed parameter type

    void controlFan(bool state);
    void controlMixer(bool state);
    void controlDispenser(bool state);
    void controlPump(bool state);
};

================================================================================
File: include\Globals.h
================================================================================

#pragma once

#include "ModbusHandler.h"
#include "DeviceManager.h"
#include "Motor.h"

extern ModbusHandler* modbusHandler;
extern DeviceManager* deviceManager;
extern Motor** motors;  // Changed from Motor* to Motor**

================================================================================
File: include\ModbusHandler.h
================================================================================

#pragma once
#include <ArduinoModbus.h>
#include <ArduinoRS485.h>
#include <Arduino.h>
#include "Config.h"

class ModbusHandler {
private:
    HardwareSerial& port;
    uint8_t slaveID;
    uint16_t dutyShadows[15];
    uint16_t freqShadows[15];
    uint16_t deviceShadows[4];
    uint16_t startShadow;

public:
    ModbusHandler(HardwareSerial& portRef, uint8_t slaveRef);
    void begin(unsigned long baudrate = BAUDRATE);
    void task();

    uint16_t getHreg(uint16_t addr);
    uint16_t getIreg(uint16_t addr);
    void setHreg(uint16_t addr, uint16_t value);
    void setIreg(uint16_t addr, uint16_t value);

    void handleMotorWrite(uint16_t addr, uint16_t val);
    void handleDeviceWrite(int addr, uint16_t val);
    void handleSystemWrite(int addr, uint16_t val);
};

================================================================================
File: include\Motor.h
================================================================================

#pragma once
#include "ModbusHandler.h"
#include "TemperatureSensor.h"
#include <Arduino.h>  // Needed for pinMode, analogRead, etc.

class Motor {
public:
    // Constructor takes hardware + sensor bindings
    Motor(uint8_t id, uint8_t pwmPin, uint8_t currentPin, TemperatureSensor* tempSensor, ModbusHandler& modbus);

    // Initializes pins, PWM, and Modbus registers
    void begin();

    // Main update loop (to be called regularly)
    void update();

    // Update PWM duty cycle (0–1000 means 0–100%)
    void setDuty(uint16_t duty);

    // Update PWM frequency (e.g., 100 Hz – 30,000 Hz)
    void setFrequency(uint32_t freq);

    // Return internal status: 0–3 (OK, warning, fault, sensor error)
    uint8_t getStatus() const;

private:
    uint8_t id;             // Motor index (0–14)
    uint8_t pwmPin;         // PWM output pin
    uint8_t currentPin;     // Current sensor pin (analog)
    TemperatureSensor* tempSensor;  // Linked DS18B20 or similar
    ModbusHandler& modbusHandler;

    uint16_t dutyCycle;     // Current duty cycle
    uint8_t status;         // Current motor status

    // Read current with exponential smoothing filter
    uint16_t readFilteredCurrent();
};


================================================================================
File: include\PWMController.h
================================================================================

// PWMController.h
#pragma once
#include <Arduino.h>  // Provides types like uint8_t and utility macros like constrain()

// Class to control hardware PWM on Arduino Mega (ATmega2560)
class PWMController {
public:
    // Initializes all timers (0 to 5) into appropriate PWM mode
    static void initialize();

    // Sets the frequency for a specific pin by modifying timer prescaler or TOP
    static void setFrequency(uint8_t pin, uint32_t freq);

    // Sets the duty cycle (0–1000) for a specific pin
    static void setDutyCycle(uint8_t pin, uint16_t duty);
};


================================================================================
File: include\README
================================================================================


This directory is intended for project header files.

A header file is a file containing C declarations and macro definitions
to be shared between several project source files. You request the use of a
header file in your project source file (C, C++, etc) located in `src` folder
by including it, with the C preprocessing directive `#include'.

```src/main.c

#include "header.h"

int main (void)
{
 ...
}
```

Including a header file produces the same results as copying the header file
into each source file that needs it. Such copying would be time-consuming
and error-prone. With a header file, the related declarations appear
in only one place. If they need to be changed, they can be changed in one
place, and programs that include the header file will automatically use the
new version when next recompiled. The header file eliminates the labor of
finding and changing all the copies as well as the risk that a failure to
find one copy will result in inconsistencies within a program.

In C, the convention is to give header files names that end with `.h'.

Read more about using header files in official GCC documentation:

* Include Syntax
* Include Operation
* Once-Only Headers
* Computed Includes

https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html


================================================================================
File: include\SystemCore.h
================================================================================

#pragma once
// Prevents multiple inclusions of this header file during compilation.

#include "ModbusHandler.h"     // Handles Modbus RTU communication (master-slave protocol)
#include "TemperatureSensor.h" // Interface for DS18B20 or similar temperature sensors
#include "Motor.h"             // Motor class: includes PWM, current sensing, and temperature safety
#include "DeviceManager.h"     // Manages auxiliary actuators like fan, pump, mixer, etc.
#include "Config.h"            // Global configuration constants (e.g., NUM_MOTORS)
#include <Arduino.h>           // Arduino core functions and types (pinMode, millis, digitalWrite, etc.)

// Main orchestrator of the embedded system. Handles setup, runtime control, and data flow.
class SystemCore {
public:
    // Constructor to initialize internal members (could also be used to preload configs)
    SystemCore();
    
    // Destructor to clean up dynamically allocated objects
    ~SystemCore();

    // Sets up all subsystems (sensors, motors, Modbus, etc.)
    void setup();

    // Main runtime loop. Should be called repeatedly from Arduino's loop()
    void loop();

    // Allows ModbusHandler to access private members like motors[] directly.
    // Useful for implementing indirect register callbacks.
    friend class ModbusHandler;

private:
    // --- Subsystems ---

    ModbusHandler modbus;               // Modbus RTU slave handler (interfaces with external master like Python GUI)

    TemperatureSensor airSensor;        // Ambient air temperature sensor (DS18B20 or similar)
    TemperatureSensor waterSensor;      // Water temperature sensor (same interface as above)

    TemperatureSensor* motorSensors[NUM_MOTORS]; // Array of pointers to per-motor temperature sensors

    Motor* motors[NUM_MOTORS];          // Array of pointers to core motor control objects

    DeviceManager deviceManager;        // Controls peripheral devices (fan, mixer, pump, etc.)

    uint64_t accumulated_ticks = 0;
    uint32_t last_overflow_snapshot = 0;
    uint16_t current_timer0_prescaler = 64;

    // --- Timekeeping ---

    // Custom millisecond counter (optionally extended to 64-bit for rollover-safe timing)
    uint64_t millisCustom();

    // Stores prescaler state for custom millis if using a timer overflow counter
    uint16_t prev_prescaler;
};

// Declares a global instance accessible throughout the codebase.
// Allows Modbus callbacks or interrupt handlers to refer to the central system state.
extern SystemCore systemCore;

================================================================================
File: include\TemperatureSensor.h
================================================================================

#pragma once  // Ensure the header is only included once during compilation

#include <OneWire.h>             // For communicating with 1-Wire devices like DS18B20
#include <DallasTemperature.h>   // High-level wrapper for 1-Wire temperature sensors
#include <Arduino.h>             // Core Arduino definitions and types

// Class to encapsulate a single DS18B20 temperature sensor
class TemperatureSensor {
private:
    OneWire oneWire;             // OneWire bus instance, bound to a specific pin
    DallasTemperature sensor;    // DallasTemperature library interface for reading sensor(s)
    
    uint16_t regTemp;            // Modbus register to store current temperature
    uint16_t regLowThreshold;    // Modbus register for minimum safe temperature
    uint16_t regHighThreshold;   // Modbus register for maximum safe temperature
    
    int16_t temperature;         // Last read temperature in 0.1°C precision (e.g., 254 = 25.4°C)
                                 // Changed from uint16_t to handle negative Celsius values
    uint8_t status;              // Encoded sensor status (e.g., 0=OK, 1=too low, 2=too high)
    uint64_t lastTemperatureRequest = 0; // Instance-specific timestamp

public:
    // Constructor: specify GPIO pin and Modbus register mappings
    TemperatureSensor(uint8_t pin, uint16_t tempReg, uint16_t lowThresholdReg, uint16_t highThresholdReg);

    // Initializes OneWire and DallasTemperature libraries
    void begin();

    // Reads temperature from sensor and updates Modbus registers and status
    void update();

    // Returns latest temperature value in 0.1°C precision (e.g., 325 = 32.5°C)
    int16_t getTemperature() const;

    // Returns current status code
    uint8_t getStatus() const;

    // Read data from sensors (Take's a bit time so we need it to call before reading temps)
    void requestTemperatures(uint64_t now);
};


================================================================================
File: lib\README
================================================================================


This directory is intended for project specific (private) libraries.
PlatformIO will compile them to static libraries and link into the executable file.

The source code of each library should be placed in a separate directory
("lib/your_library_name/[Code]").

For example, see the structure of the following example libraries `Foo` and `Bar`:

|--lib
|  |
|  |--Bar
|  |  |--docs
|  |  |--examples
|  |  |--src
|  |     |- Bar.c
|  |     |- Bar.h
|  |  |- library.json (optional. for custom build options, etc) https://docs.platformio.org/page/librarymanager/config.html
|  |
|  |--Foo
|  |  |- Foo.c
|  |  |- Foo.h
|  |
|  |- README --> THIS FILE
|
|- platformio.ini
|--src
   |- main.c

Example contents of `src/main.c` using Foo and Bar:
```
#include <Foo.h>
#include <Bar.h>

int main (void)
{
  ...
}

```

The PlatformIO Library Dependency Finder will find automatically dependent
libraries by scanning project source files.

More information about PlatformIO Library Dependency Finder
- https://docs.platformio.org/page/librarymanager/ldf.html


================================================================================
File: src\DeviceManager.cpp
================================================================================

#include "DeviceManager.h"
#include "ModbusHandler.h"
#include "Config.h"
#include "Globals.h"

void DeviceManager::begin() {
    pinMode(FAN_PIN, OUTPUT);
    pinMode(MIXER_PIN, OUTPUT);
    pinMode(DISPENSER_PIN, OUTPUT);
    pinMode(PUMP_PIN, OUTPUT);

    // Optional: clear state
    digitalWrite(FAN_PIN, LOW);
    digitalWrite(MIXER_PIN, LOW);
    digitalWrite(DISPENSER_PIN, LOW);
    digitalWrite(PUMP_PIN, LOW);
}

void DeviceManager::update(const TemperatureSensor& airSensor, 
                           const TemperatureSensor& waterSensor, 
                           const Motor* const* motors) {
    // --- Fan logic ---
    uint16_t airTemp = airSensor.getTemperature();
    uint16_t airLow = modbusHandler->getHreg(ModbusReg::AIR_TEMP_LOW);
    uint16_t airHigh = modbusHandler->getHreg(ModbusReg::AIR_TEMP_HIGH);
    bool fanState = false;

    if (airTemp != 0xFFFF) {
        fanState = (airTemp >= airHigh) || (airTemp <= airLow);
    }
    controlFan(fanState);

    // --- Mixer logic ---
    uint16_t waterTemp = waterSensor.getTemperature();
    uint16_t waterLow = modbusHandler->getHreg(ModbusReg::WATER_TEMP_LOW);
    uint16_t waterHigh = modbusHandler->getHreg(ModbusReg::WATER_TEMP_HIGH);
    bool mixerState = false;

    if (waterTemp != 0xFFFF) {
        mixerState = (waterTemp >= waterHigh) || (waterTemp <= waterLow);
    }
    controlMixer(mixerState);

    // --- Dispenser logic ---
    bool dispenserState = (waterTemp != 0xFFFF && waterTemp >= waterHigh);
    controlDispenser(dispenserState);

    // --- Pump logic ---
    bool pumpState = false;
    for (int i = 0; i < NUM_MOTORS; i++) {
        if (motors[i]->getStatus() < 2 && 
            modbusHandler->getHreg(ModbusReg::DUTY_BASE + i) > 0) {
            pumpState = true;
            break;
        }
    }
    controlPump(pumpState);
}

// Device control methods with Modbus feedback

void DeviceManager::controlFan(bool state) {
    digitalWrite(FAN_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 0, state ? 1 : 0);
}

void DeviceManager::controlMixer(bool state) {
    digitalWrite(MIXER_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 1, state ? 1 : 0);
}

void DeviceManager::controlDispenser(bool state) {
    digitalWrite(DISPENSER_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 2, state ? 1 : 0);
}

void DeviceManager::controlPump(bool state) {
    digitalWrite(PUMP_PIN, state ? HIGH : LOW);
    modbusHandler->setIreg(ModbusReg::DEV_STATUS_BASE + 3, state ? 1 : 0);
}

================================================================================
File: src\Globals.cpp
================================================================================

#include "Globals.h"

ModbusHandler* modbusHandler = nullptr;
DeviceManager* deviceManager = nullptr;
Motor** motors = nullptr;  // Changed from Motor* to Motor**

================================================================================
File: src\main.cpp
================================================================================

#include <Arduino.h>
#include <SystemCore.h>
#include "Config.h"
#include <avr/wdt.h>

SystemCore systemCore;

void setup() {
  systemCore.setup();
  // wdt_enable(WDTO_2S);
}

void loop() {
  // wdt_enable(WDTO_2S);
  systemCore.loop();
}

================================================================================
File: src\ModbusHandler.cpp
================================================================================

#include "ModbusHandler.h"
#include "Motor.h"
#include "DeviceManager.h"
#include "Config.h"
#include "Globals.h"

ModbusHandler::ModbusHandler(HardwareSerial& portRef, uint8_t slaveRef)
    : port(portRef), slaveID(slaveRef) {}

void ModbusHandler::begin(unsigned long baudrate) {
    port.begin(baudrate);  // For logging and Modbus

    // Begin with explicit parity (even) for validation
    if (!ModbusRTUServer.begin(slaveID, baudrate, SERIAL_8E1)) {
        while (1);
    }

    // Configure ranges (larger for safety)
    ModbusRTUServer.configureHoldingRegisters(0, 1000);
    ModbusRTUServer.configureInputRegisters(0, 1000);

    // Init registers
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::START_REG_ADDR, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW + 1, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW + 2, 0);
    ModbusRTUServer.inputRegisterWrite(ModbusReg::TIME_LOW + 3, 0);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::MOTOR_TEMP_CRIT, TEMP_CRITICAL);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::MOTOR_CURR_CRIT, CURR_CRITICAL);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::AIR_TEMP_LOW, TEMP_WARNING);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::AIR_TEMP_HIGH, TEMP_CRITICAL);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::WATER_TEMP_LOW, TEMP_WARNING);
    ModbusRTUServer.holdingRegisterWrite(ModbusReg::WATER_TEMP_HIGH, TEMP_CRITICAL);

    // Init duty and freq shadows and registers
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        ModbusRTUServer.holdingRegisterWrite(ModbusReg::DUTY_BASE + i, 0);
        dutyShadows[i] = 0;
        ModbusRTUServer.holdingRegisterWrite(ModbusReg::FREQ_BASE + i, 1000);
        freqShadows[i] = 1000;
    }
    memset(deviceShadows, 0, sizeof(deviceShadows));
    startShadow = 0;

}

void ModbusHandler::task() {
    static uint8_t errorCount = 0;
    
    int pollResult = ModbusRTUServer.poll();
    if (pollResult == -1) {
        if (++errorCount > 10) {
            // Reset Modbus state after 10 errors
            ModbusRTUServer.begin(slaveID, BAUDRATE, SERIAL_8E1);
            errorCount = 0;
        }
    } else {
        errorCount = 0;
    }
    if (!port.available()) return;

    // int pollResult = ModbusRTUServer.poll();
    // if (pollResult == -1) {
    //     // Error handling (e.g., frame/CRC error); increment counter or log
    // }

    // Check for changes in holding registers (reactive handling)
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        uint16_t dutyVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::DUTY_BASE + i);
        if (dutyVal != dutyShadows[i]) {
            handleMotorWrite(ModbusReg::DUTY_BASE + i, dutyVal);
            dutyShadows[i] = dutyVal;
        }
        uint16_t freqVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::FREQ_BASE + i);
        if (freqVal != freqShadows[i]) {
            handleMotorWrite(ModbusReg::FREQ_BASE + i, freqVal);
            freqShadows[i] = freqVal;
        }
    }
    for (uint8_t i = 0; i < 4; i++) {
        uint16_t devVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::DEV_STATUS_BASE + i);
        if (devVal != deviceShadows[i]) {
            handleDeviceWrite(ModbusReg::DEV_STATUS_BASE + i, devVal);
            deviceShadows[i] = devVal;
        }
    }
    uint16_t startVal = ModbusRTUServer.holdingRegisterRead(ModbusReg::START_REG_ADDR);
    if (startVal != startShadow) {
        handleSystemWrite(ModbusReg::START_REG_ADDR, startVal);
        startShadow = startVal;
    }
}

uint16_t ModbusHandler::getHreg(uint16_t addr) {
    return ModbusRTUServer.holdingRegisterRead(addr);
}

uint16_t ModbusHandler::getIreg(uint16_t addr) {
    return ModbusRTUServer.inputRegisterRead(addr);
}

void ModbusHandler::setHreg(uint16_t addr, uint16_t value) {
    ModbusRTUServer.holdingRegisterWrite(addr, value);
}

void ModbusHandler::setIreg(uint16_t addr, uint16_t value) {
    ModbusRTUServer.inputRegisterWrite(addr, value);
}

void ModbusHandler::handleMotorWrite(uint16_t addr, uint16_t val) {  // Changed parameter type to uint16_t
    if (addr >= ModbusReg::DUTY_BASE &&
        addr < ModbusReg::DUTY_BASE + NUM_MOTORS) {
        uint8_t id = addr - ModbusReg::DUTY_BASE;
        motors[id]->setDuty(val);
    } else if (addr >= ModbusReg::FREQ_BASE &&
               addr < ModbusReg::FREQ_BASE + NUM_MOTORS) {
        uint8_t id = addr - ModbusReg::FREQ_BASE;
        motors[id]->setFrequency(val);
    }
}

void ModbusHandler::handleDeviceWrite(int addr, uint16_t val) {
    if (addr == ModbusReg::FAN_REG) deviceManager->controlFan(val > 0);
    else if (addr == ModbusReg::MIXER_REG) deviceManager->controlMixer(val > 0);
    else if (addr == ModbusReg::DISPENSER_REG) deviceManager->controlDispenser(val > 0);
    else if (addr == ModbusReg::PUMP_REG) deviceManager->controlPump(val > 0);
}

void ModbusHandler::handleSystemWrite(int addr, uint16_t val) {
    if (val == 0) {
        for (int i = 0; i < NUM_MOTORS; i++) {
            motors[i]->setDuty(0);
        }
        deviceManager->controlFan(false);
        deviceManager->controlMixer(false);
        deviceManager->controlDispenser(false);
        deviceManager->controlPump(false);
    }
}

================================================================================
File: src\Motor.cpp
================================================================================

#include "Motor.h"
#include "PWMController.h"
#include "ModbusHandler.h"
#include "Config.h"
#include "Globals.h"

Motor::Motor(uint8_t id, uint8_t pwmPin, uint8_t currentPin, TemperatureSensor* tempSensor, ModbusHandler& modbus)
    : id(id), pwmPin(pwmPin), currentPin(currentPin), tempSensor(tempSensor), modbusHandler(modbus),
      dutyCycle(0), status(0) {}

void Motor::begin() {
    pinMode(pwmPin, OUTPUT);
    pinMode(currentPin, INPUT);

    // Default PWM setup (1 kHz, 0% duty)
    PWMController::setFrequency(pwmPin, 1000);
    PWMController::setDutyCycle(pwmPin, 0);
}

void Motor::update() {
    uint16_t current = readFilteredCurrent();  // Smoothed current
    modbusHandler.setIreg(ModbusReg::CURR_BASE + id, current);

    int16_t temp = tempSensor->getTemperature();  // in 1/100 °C
    modbusHandler.setIreg(ModbusReg::TEMP_BASE + id, static_cast<uint16_t>(temp));

    uint8_t tempStatus = tempSensor->getStatus();  // 0: OK, 1: warn, 2: crit, 3: sensor err
    uint16_t tempCritThreshold = modbusHandler.getHreg(ModbusReg::MOTOR_TEMP_CRIT);
    uint16_t currCritThreshold = modbusHandler.getHreg(ModbusReg::MOTOR_CURR_CRIT);

    if (tempStatus == 3) {
        status = 3;         // Sensor error
        setDuty(0);
    } else if (temp >= static_cast<int16_t>(tempCritThreshold) || current >= currCritThreshold) {
        status = 2;         // Critical overtemp or overcurrent
        setDuty(0);
    } else if (tempStatus > 0) {
        status = 1;         // Warning
        // Still running
    } else {
        status = 0;         // Normal
    }

    modbusHandler.setIreg(ModbusReg::STATUS_BASE + id, status);
}

void Motor::setDuty(uint16_t duty) {
    dutyCycle = (duty > 1000) ? 1000 : duty;  // Clamp to 1000
    PWMController::setDutyCycle(pwmPin, dutyCycle);
}

void Motor::setFrequency(uint32_t freq) {
    PWMController::setFrequency(pwmPin, freq);
}

uint16_t Motor::readFilteredCurrent() {
    static float filtered[NUM_MOTORS] = {0};  // One filter per motor
    uint16_t raw = analogRead(currentPin);    // 0–1023

    // Exponential moving average filter (low-pass)
    filtered[id] = 0.15f * raw + 0.85f * filtered[id];

    return (filtered[id] - 512) * 1000 / 66;  // For ACS712-5A, if 5V ref
}

uint8_t Motor::getStatus() const {
    return status;
}

================================================================================
File: src\PWMController.cpp
================================================================================

// PWMController.cpp
#include "PWMController.h"
#include "Config.h"     // Contains MIN_PWM_FREQ and MAX_PWM_FREQ
#include <Arduino.h>
#include <avr/io.h>     // Direct access to AVR timer registers

// Initialize all timers (Timer0–Timer5) in PWM mode
void PWMController::initialize() {
    // ---------------- Timer 0: Pins 13 (OC0A), 4 (OC0B) ----------------
    TCCR0A = _BV(WGM00) | _BV(COM0A1) | _BV(COM0B1);  // Phase Correct PWM mode, clear OC0A/OC0B on compare match
    TCCR0B = _BV(CS01) | _BV(CS00);                   // Clock prescaler = /64

    // ---------------- Timer 1: Pins 11 (OC1A), 12 (OC1B) ----------------
    TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(WGM11);  // Phase and frequency correct PWM
    TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS11);     // Prescaler = /8
    ICR1 = 2000;                                      // TOP value (sets PWM period)

    // ---------------- Timer 2: Pins 9 (OC2B), 10 (OC2A) ----------------
    TCCR2A = _BV(WGM20) | _BV(WGM21) | _BV(COM2A1) | _BV(COM2B1); // Fast PWM
    TCCR2B = _BV(CS22);                                            // Prescaler = /64

    // ---------------- Timer 3: Pins 2 (OC3B), 3 (OC3C), 5 (OC3A) ----------------
    TCCR3A = _BV(COM3A1) | _BV(COM3B1) | _BV(WGM31); // PWM, Phase & Frequency Correct
    TCCR3B = _BV(WGM33) | _BV(WGM32) | _BV(CS31);    // Prescaler = /8
    ICR3 = 2000;                                     // TOP

    // ---------------- Timer 4: Pins 6 (OC4A), 7 (OC4B), 8 (OC4C) ----------------
    TCCR4A = _BV(COM4A1) | _BV(COM4B1) | _BV(WGM41);
    TCCR4B = _BV(WGM43) | _BV(WGM42) | _BV(CS41);
    ICR4 = 2000;

    // ---------------- Timer 5: Pins 44 (OC5C), 45 (OC5B), 46 (OC5A) ----------------
    TCCR5A = _BV(COM5A1) | _BV(COM5B1) | _BV(WGM51);
    TCCR5B = _BV(WGM53) | _BV(WGM52) | _BV(CS51);
    ICR5 = 2000;
}

// Set PWM frequency for the given pin
void PWMController::setFrequency(uint8_t pin, uint32_t freq) {
    if (freq == 0) return;
    freq = constrain(freq, MIN_PWM_FREQ, MAX_PWM_FREQ);  // Safety clamp

    // -------- Timer 0 (8-bit): Pins 4, 13 --------
    if (pin == 13 || pin == 4) {
        // Change prescaler to modify frequency (limited resolution)
        if (freq >= 30000)       TCCR0B = (TCCR0B & 0xF8) | 0x01; // ~31.3 kHz
        else if (freq >= 4000)   TCCR0B = (TCCR0B & 0xF8) | 0x02; // ~3.9 kHz
        else if (freq >= 1000)   TCCR0B = (TCCR0B & 0xF8) | 0x03; // ~490 Hz
        else if (freq >= 300)    TCCR0B = (TCCR0B & 0xF8) | 0x04; // ~122 Hz
        else                     TCCR0B = (TCCR0B & 0xF8) | 0x05; // ~30 Hz
    }

    // -------- Timer 2 (8-bit): Pins 9, 10 --------
    else if (pin == 9 || pin == 10) {
        if (freq >= 30000)       TCCR2B = (TCCR2B & 0xF8) | 0x01;
        else if (freq >= 8000)   TCCR2B = (TCCR2B & 0xF8) | 0x02;
        else if (freq >= 2000)   TCCR2B = (TCCR2B & 0xF8) | 0x03;
        else if (freq >= 1000)   TCCR2B = (TCCR2B & 0xF8) | 0x04;
        else if (freq >= 500)    TCCR2B = (TCCR2B & 0xF8) | 0x05;
        else if (freq >= 250)    TCCR2B = (TCCR2B & 0xF8) | 0x06;
        else                     TCCR2B = (TCCR2B & 0xF8) | 0x07;
    }

    // -------- 16-bit Timers (1,3,4,5): Set ICRx as TOP --------
    else {
        uint32_t top = F_CPU / (8UL * freq) - 1; // F_CPU = 16MHz, Prescaler = /8
        switch (pin) {
            case 11: case 12:          ICR1 = top; break;
            case 2: case 3: case 5:    ICR3 = top; break;
            case 6: case 7: case 8:    ICR4 = top; break;
            case 44: case 45: case 46: ICR5 = top; break;
        }
    }
}

// Set PWM duty cycle (0–1000) for the given pin
void PWMController::setDutyCycle(uint8_t pin, uint16_t duty) {
    noInterrupts();
    duty = constrain(duty, 0, 1000);  // Duty expressed in per-mille (0–1000)
    uint16_t ocrValue = 0;

    switch (pin) {
        // --- Timer1 (ICR1) ---
        case 11: ocrValue = (uint32_t)duty * ICR1 / 1000UL; OCR1A = ocrValue; break;
        case 12: ocrValue = (uint32_t)duty * ICR1 / 1000UL; OCR1B = ocrValue; break;

        // --- Timer3 (ICR3) ---
        case 2:  ocrValue = (uint32_t)duty * ICR3 / 1000UL; OCR3B = ocrValue; break;
        case 3:  ocrValue = (uint32_t)duty * ICR3 / 1000UL; OCR3C = ocrValue; break;
        case 5:  ocrValue = (uint32_t)duty * ICR3 / 1000UL; OCR3A = ocrValue; break;

        // --- Timer4 (ICR4) ---
        case 6:  ocrValue = (uint32_t)duty * ICR4 / 1000UL; OCR4A = ocrValue; break;
        case 7:  ocrValue = (uint32_t)duty * ICR4 / 1000UL; OCR4B = ocrValue; break;
        case 8:  ocrValue = (uint32_t)duty * ICR4 / 1000UL; OCR4C = ocrValue; break;

        // --- Timer2 (8-bit, TOP=255) ---
        case 9:  ocrValue = (uint32_t)duty * 255 / 1000UL; OCR2B = ocrValue; break;
        case 10: ocrValue = (uint32_t)duty * 255 / 1000UL; OCR2A = ocrValue; break;

        // --- Timer0 (8-bit, TOP=255) ---
        case 13: ocrValue = (uint32_t)duty * 255 / 1000UL; OCR0A = ocrValue; break;
        case 4:  ocrValue = (uint32_t)duty * 255 / 1000UL; OCR0B = ocrValue; break;

        // --- Timer5 (ICR5) ---
        case 44: ocrValue = (uint32_t)duty * ICR5 / 1000UL; OCR5C = ocrValue; break;
        case 45: ocrValue = (uint32_t)duty * ICR5 / 1000UL; OCR5B = ocrValue; break;
        case 46: ocrValue = (uint32_t)duty * ICR5 / 1000UL; OCR5A = ocrValue; break;
    }
    interrupts();
}

================================================================================
File: src\SystemCore.cpp
================================================================================

#include "Globals.h"
#include "SystemCore.h"
#include "Config.h"
#include "PWMController.h"   // Add this line

SystemCore::SystemCore()
    : modbus(Serial, SLAVE_ID),
      airSensor(AIR_TEMP_PIN, 
                ModbusReg::AIR_TEMP_REG,
                ModbusReg::AIR_TEMP_LOW,
                ModbusReg::AIR_TEMP_HIGH),
      waterSensor(WATER_TEMP_PIN, 
                  ModbusReg::WATER_TEMP_REG,
                  ModbusReg::WATER_TEMP_LOW,
                  ModbusReg::WATER_TEMP_HIGH),
      prev_prescaler(0) {
    ::modbusHandler = &modbus;
    ::deviceManager = &deviceManager;
    ::motors = this->motors;  // Update global pointer to motor array

    // Initialize motor sensors with dynamic allocation
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motorSensors[i] = new TemperatureSensor(
            TEMP_PINS[i], 
            ModbusReg::TEMP_BASE + i,
            ModbusReg::MOTOR_TEMP_CRIT,
            0  // High threshold not used for motors
        );
    }
    
    // Initialize motors with dynamic allocation
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motors[i] = new Motor(
            i, 
            PWM_PINS[i], 
            CURRENT_PINS[i], 
            motorSensors[i],  // Pass pointer to sensor
            this->modbus
        );
    }
}

SystemCore::~SystemCore() {
    // Clean up dynamically allocated objects
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        delete motorSensors[i];
        delete motors[i];
    }
}

void SystemCore::setup() {
    PWMController::initialize();
    modbus.begin();
    
    // Initialize sensors
    airSensor.begin();
    waterSensor.begin();
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motorSensors[i]->begin();  // Pointer access
    }
    
    // Initialize motors
    for (uint8_t i = 0; i < NUM_MOTORS; i++) {
        motors[i]->begin();  // Pointer access
    }
    
    // Initialize devices
    deviceManager.begin();
}

void SystemCore::loop() {
    modbus.task();
    
    static uint64_t lastMotorUpdate = 0;
    static uint64_t lastTempUpdate = 0;
    uint64_t now = millisCustom() * 2;
    
    // Update motor status every 100ms
    if (now - lastMotorUpdate >= 500) {
        lastMotorUpdate = now;
        for (uint8_t i = 0; i < NUM_MOTORS; i += 3) { // Process 2 motors per cycle
            if (i < NUM_MOTORS) motors[i]->update();
            if (i+1 < NUM_MOTORS) motors[i+1]->update();
            if (i+2 < NUM_MOTORS) motors[i+2]->update();
            modbus.task(); // Handle Modbus between batches
        }
    }

    // Update temperature and devices every 1000ms
    if (now - lastTempUpdate >= 1000) {
        lastTempUpdate = now;

        Serial.println();
        Serial.print(modbus.getIreg(ModbusReg::TIME_LOW + 3));
        Serial.print(modbus.getIreg(ModbusReg::TIME_LOW + 2));
        Serial.print(modbus.getIreg(ModbusReg::TIME_LOW + 1));
        Serial.print(modbus.getIreg(ModbusReg::TIME_LOW));

        // Request temperatures first
        for (uint8_t i = 0; i < NUM_MOTORS; i++) {
            motorSensors[i]->requestTemperatures(now);  // Pointer access
        }

        // Then update all temperature readings
        for (uint8_t i = 0; i < NUM_MOTORS; i++) {
            motorSensors[i]->update();  // Pointer access
        }

        airSensor.update();
        waterSensor.update();
        
        // Update devices (pass pointer to motor array)
        deviceManager.update(airSensor, waterSensor, motors);
        
        // Update timestamp register
        modbus.setIreg(ModbusReg::TIME_LOW, uint16_t(now & 0xFFFF));
        modbus.setIreg(ModbusReg::TIME_LOW + 1, uint16_t((now >> 16) & 0xFFFF));
        modbus.setIreg(ModbusReg::TIME_LOW + 2, uint16_t((now >> 32) & 0xFFFF));
        modbus.setIreg(ModbusReg::TIME_LOW + 3, uint16_t((now >> 48) & 0xFFFF));
    }
}

uint64_t SystemCore::millisCustom() {
    extern volatile unsigned long timer0_overflow_count;
    
    uint8_t tcnt0_snapshot;
    uint32_t overflow_snapshot;

    // Determine the new prescaler directly from the register
    uint8_t prescaler_bits = TCCR0B & 0x07;
    uint16_t new_prescaler;
    switch (prescaler_bits) {
        case 1: new_prescaler = 1; break;
        case 2: new_prescaler = 8; break;
        case 3: new_prescaler = 64; break;
        case 4: new_prescaler = 256; break;
        case 5: new_prescaler = 1024; break;
        default: new_prescaler = 64; break;
    }

    noInterrupts();
    tcnt0_snapshot = TCNT0;
    overflow_snapshot = timer0_overflow_count;
    // This check is crucial to catch an overflow that happens right as we read the registers
    if ((TIFR0 & _BV(TOV0)) && (tcnt0_snapshot < 255)) {
        overflow_snapshot++;
    }
    interrupts();

    // The core logic: If the prescaler has changed, we finalize the time
    // accumulated with the OLD prescaler and add it to our master accumulator.
    if (new_prescaler != current_timer0_prescaler) {
        // Calculate overflows since last check and convert to ticks using the OLD prescaler
        uint32_t overflows_since_last = overflow_snapshot - last_overflow_snapshot;
        accumulated_ticks += (uint64_t)overflows_since_last * 256 * current_timer0_prescaler;
        
        // Update the last snapshot and the current prescaler for the next run
        last_overflow_snapshot = overflow_snapshot;
        current_timer0_prescaler = new_prescaler;
    }

    // Calculate total ticks: the master accumulator plus the ticks in the current cycle
    uint64_t overflows_since_last = overflow_snapshot - last_overflow_snapshot;
    uint64_t ticks_since_last_update = (overflows_since_last * 256 + tcnt0_snapshot) * current_timer0_prescaler;
    uint64_t total_ticks = accumulated_ticks + ticks_since_last_update;


    // Convert total CPU ticks to milliseconds using integer math
    return total_ticks / (F_CPU / 1000UL);
}

================================================================================
File: src\TemperatureSensor.cpp
================================================================================

#include "TemperatureSensor.h"
#include "ModbusHandler.h"
#include "Config.h"
#include "Globals.h"


// Constructor: initializes sensor objects and register mappings
TemperatureSensor::TemperatureSensor(uint8_t pin, uint16_t tempReg, 
                     uint16_t lowThresholdReg, uint16_t highThresholdReg) 
    : oneWire(pin),                // Initialize OneWire bus on specified pin
      sensor(&oneWire),           // Bind DallasTemperature instance to OneWire bus
      regTemp(tempReg),           // Register for current temperature value
      regLowThreshold(lowThresholdReg),   // Register for low temperature threshold
      regHighThreshold(highThresholdReg), // Register for high temperature threshold
      temperature(0),             // Initialize temperature to 0
      status(0) {}                // Initial status: normal

// Initializes the temperature sensor hardware
void TemperatureSensor::begin() {
    sensor.begin();               // Initialize DallasTemperature library
    sensor.setResolution(10);     // Set sensor resolution (11 bits = 0.125°C precision)
    sensor.setWaitForConversion(false);
}

void TemperatureSensor::requestTemperatures(uint64_t now) {
    if (now - lastTemperatureRequest > 1000) {
        sensor.requestTemperatures(); // Trigger temperature reading from DS18B20
        lastTemperatureRequest = now;
    }
}

// Reads temperature, checks thresholds, and updates Modbus registers
void TemperatureSensor::update() {
    if (sensor.isConversionComplete()) {
        float tempC = sensor.getTempCByIndex(0); // Read the first sensor on the bus
    
        if (tempC == DEVICE_DISCONNECTED_C) {
            // Handle sensor disconnect case
            temperature = -32768;     // INT16_MIN sentinel value to indicate error
            status = 3;               // Status code for disconnected
        } else {
            // Convert temperature to centi-degrees (e.g., 25.34°C → 2534)
            temperature = static_cast<int16_t>(tempC * 100); 
            
            // Read threshold values from holding registers
            uint16_t lowThreshold = modbusHandler->getHreg(regLowThreshold);
            uint16_t highThreshold = modbusHandler->getHreg(regHighThreshold);

            // Compare and classify temperature status
            if (temperature >= static_cast<int16_t>(highThreshold))
                status = 2; // Temperature above upper limit
            else if (temperature <= static_cast<int16_t>(lowThreshold))
                status = 1; // Temperature below lower limit
            else
                status = 0; // Temperature within acceptable range
        }

        // Write temperature to input register (read-only from master perspective)
        modbusHandler->setIreg(regTemp, static_cast<uint16_t>(temperature));
        // Note: If temperature is negative, casting to uint16_t will wrap around,
        // which may need special handling on Modbus master side.
    }
}

// Getter: returns raw centi-degree temperature value (can be negative)
// int16_t TemperatureSensor::getTemperature() const {
//     if (temperature < 0) {
//         return 0;
//     }
//     return temperature;
// }
int16_t TemperatureSensor::getTemperature() const {
    return temperature;
}

// Getter: returns current status flag (0=OK, 1=Low, 2=High, 3=Disconnected)
uint8_t TemperatureSensor::getStatus() const {
    return status;
}

================================================================================
File: test\ArduinoStubs.h
================================================================================



================================================================================
File: test\Config.h
================================================================================

#pragma once
#include <Arduino.h>  // Needed for pin constants


// Error codes
enum ErrorCode {
    ERR_NO_ERROR = 0,
    ERR_TEMP_LOW = 1,
    ERR_TEMP_HIGH = 2, 
    ERR_SENSOR_DISCONNECTED = 3,
    ERR_OVERCURRENT = 4,
    ERR_MODBUS_CRC_FAIL = 5,
    ERR_MODBUS_TIMEOUT = 6
};

// Serial port configuration
constexpr uint32_t BAUDRATE = 115200;

// -------------------------
// Pin Configuration
// -------------------------

// Motor control PWM output pins (software/hardware PWM)
constexpr uint8_t PWM_PINS[15] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 44, 45, 46};
constexpr uint8_t SLAVE_ID = 1;

// Motor current sensor analog input pins (ACS712 or similar)
constexpr uint8_t CURRENT_PINS[15] = {A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14};

// Motor temperature DS18B20 sensor digital input pins
constexpr uint8_t TEMP_PINS[15] = {22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36};

// System-wide sensors (also digital pins)
constexpr uint8_t WATER_TEMP_PIN = 20;  // ⚠️ Also I2C SDA
constexpr uint8_t AIR_TEMP_PIN = 21;    // ⚠️ Also I2C SCL

// Output control pins for actuators
constexpr uint8_t FAN_PIN = 40;
constexpr uint8_t MIXER_PIN = 41;
constexpr uint8_t DISPENSER_PIN = 42;
constexpr uint8_t PUMP_PIN = 43;

// -------------------------
// Modbus Register Map
// -------------------------
namespace ModbusReg {

    // --- Motor Parameters ---
    // Holding Registers (writeable by master)
    constexpr uint16_t DUTY_BASE = 0;      // Holding: [0–14] — duty cycle control
    constexpr uint16_t FREQ_BASE = 100;    // Holding: [100–114] — frequency control

    // Input Registers (read-only to master)
    constexpr uint16_t CURR_BASE = 200;    // Input: [200–214] — motor current values
    constexpr uint16_t TEMP_BASE = 300;    // Input: [300–314] — motor temperature values
    constexpr uint16_t STATUS_BASE = 400;  // Input: [400–414] — motor status (e.g. overtemp, error)

    // Thresholds (Holding registers, writeable by master)
    constexpr uint16_t MOTOR_TEMP_CRIT = 500;
    constexpr uint16_t MOTOR_CURR_CRIT = 501;

    // --- System Parameters ---
    constexpr uint16_t START_REG_ADDR = 900;
    constexpr uint16_t TIME_LOW = 901;

    // Air Temp
    constexpr uint16_t AIR_TEMP_REG = 920;
    constexpr uint16_t AIR_TEMP_LOW = 921;
    constexpr uint16_t AIR_TEMP_HIGH = 922;

    // Water Temp
    constexpr uint16_t WATER_TEMP_REG = 930;
    constexpr uint16_t WATER_TEMP_LOW = 931;
    constexpr uint16_t WATER_TEMP_HIGH = 932;

    // --- Device States ---
    constexpr uint16_t DEV_STATUS_BASE = 911;
    constexpr uint16_t FAN_REG = 911;
    constexpr uint16_t MIXER_REG = 912;
    constexpr uint16_t DISPENSER_REG = 913;
    constexpr uint16_t PUMP_REG = 914;
}

// -------------------------
// Safety & Operational Limits
// -------------------------

constexpr uint8_t NUM_MOTORS = 15;

// Temperature values scaled (e.g., 5000 = 50.00°C if using hundredths of °C)
constexpr uint16_t TEMP_WARNING  = 5000;
constexpr uint16_t TEMP_CRITICAL = 6000;
constexpr uint16_t CURR_CRITICAL = 900;     // mA or raw sensor units

// PWM frequency range (Hz)
constexpr uint16_t MIN_PWM_FREQ = 100;
constexpr uint16_t MAX_PWM_FREQ = 30000;


================================================================================
File: test\test_DeviceManager\test_DeviceManager.cpp
================================================================================

#include <unity.h>
#include "DeviceManager.h"
#include "ModbusHandler.h"
#include "TemperatureSensor.h"

// Mock ModbusHandler and sensors
class MockModbusHandler : public ModbusHandler {
public:
    uint16_t getHreg(uint16_t addr) override {
        if (addr == ModbusReg::AIR_TEMP_LOW) return 1000;  // 10.00°C
        if (addr == ModbusReg::AIR_TEMP_HIGH) return 3000; // 30.00°C
        // Add other registers as needed
        return 0;
    }
    void setIreg(uint16_t, uint16_t) override {} // No-op
};

void test_fan_control() {
    DeviceManager dm;
    MockModbusHandler mb;
    modbusHandler = &mb;
    
    TemperatureSensor airSensor(0, 0, 0, 0);
    TemperatureSensor waterSensor(0, 0, 0, 0);
    
    // Simulate valid temperature reading
    airSensor.temperature = 3500;  // 35.00°C (above high threshold)
    dm.update(airSensor, waterSensor, nullptr);
    
    // Verify fan turns on (LOW/HIGH depends on your wiring)
    // TEST_ASSERT_EQUAL(HIGH, digitalRead(FAN_PIN));
}

// Add tests for mixer, dispenser, pump...

int main() {
    UNITY_BEGIN();
    RUN_TEST(test_fan_control);
    return UNITY_END();
}


================================================================================
File: test\test_Motor\test_Motor.cpp
================================================================================

#include <unity.h>
#include "Motor.h"
#include "ModbusHandler.h"

// Mock PWM and current reading
namespace PWMController {
    void setDutyCycle(uint8_t, uint16_t) {}
    void setFrequency(uint8_t, uint32_t) {}
}
uint16_t analogRead(uint8_t) { return 512; } // Mid-range

void test_motor_overcurrent() {
    Motor motor(0, 9, A0, nullptr);
    MockModbusHandler mb;
    modbusHandler = &mb;
    mb.thresholds[ModbusReg::MOTOR_CURR_CRIT] = 5000; // 5A
    
    motor.update();
    TEST_ASSERT_EQUAL(2, motor.getStatus()); // Critical state
}

int main() {
    UNITY_BEGIN();
    RUN_TEST(test_motor_overcurrent);
    return UNITY_END();
}


================================================================================
File: test\test_SystemCore\test_SystemCore.cpp
================================================================================

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "SystemCore.h"
#include "mocks/MockModbusHandler.h"
#include "mocks/MockTemperatureSensor.h"
#include "mocks/MockMotor.h"
#include "mocks/MockDeviceManager.h"
#include "Config.h"

using ::testing::_;
using ::testing::Return;
using ::testing::NiceMock;
using ::testing::AtLeast;

// Global pointer overrides
MockModbusHandler* mockModbus;
MockDeviceManager* mockDeviceManager;
MockMotor* mockMotors[NUM_MOTORS];
MockTemperatureSensor* mockMotorSensors[NUM_MOTORS];
MockTemperatureSensor mockAirSensor;
MockTemperatureSensor mockWaterSensor;

// Time control
uint64_t currentTestTime = 0;

class SystemCoreTest : public ::testing::Test {
protected:
    SystemCore* systemCore;
    
    void SetUp() override {
        // Initialize mock pointers
        mockModbus = new NiceMock<MockModbusHandler>();
        mockDeviceManager = new NiceMock<MockDeviceManager>();
        
        for (int i = 0; i < NUM_MOTORS; i++) {
            mockMotorSensors[i] = new NiceMock<MockTemperatureSensor>();
            mockMotors[i] = new NiceMock<MockMotor>();
        }
        
        // Replace global pointers
        ::modbusHandler = mockModbus;
        ::deviceManager = mockDeviceManager;
        ::motors = (Motor**)mockMotors;
        
        // Create SystemCore instance
        systemCore = new SystemCore();
        
        // Set up default expectations
        ON_CALL(*mockModbus, begin(_)).WillByDefault(Return());
        ON_CALL(*mockDeviceManager, begin()).WillByDefault(Return());
        for (int i = 0; i < NUM_MOTORS; i++) {
            ON_CALL(*mockMotorSensors[i], begin()).WillByDefault(Return());
            ON_CALL(*mockMotors[i], begin()).WillByDefault(Return());
        }
        
        // Call setup
        systemCore->setup();
    }
    
    void TearDown() override {
        delete systemCore;
        delete mockModbus;
        delete mockDeviceManager;
        for (int i = 0; i < NUM_MOTORS; i++) {
            delete mockMotorSensors[i];
            delete mockMotors[i];
        }
    }
    
    void advanceTime(uint64_t ms) {
        currentTestTime += ms;
    }
};

TEST_F(SystemCoreTest, InitializationTest) {
    // Verify setup calls
    EXPECT_CALL(*mockModbus, begin(_)).Times(1);
    EXPECT_CALL(mockAirSensor, begin()).Times(1);
    EXPECT_CALL(mockWaterSensor, begin()).Times(1);
    for (int i = 0; i < NUM_MOTORS; i++) {
        EXPECT_CALL(*mockMotorSensors[i], begin()).Times(1);
        EXPECT_CALL(*mockMotors[i], begin()).Times(1);
    }
    EXPECT_CALL(*mockDeviceManager, begin()).Times(1);
}

TEST_F(SystemCoreTest, LoopCallsModbusTask) {
    EXPECT_CALL(*mockModbus, task()).Times(1);
    systemCore->loop();
}

TEST_F(SystemCoreTest, MotorUpdateTiming) {
    // First call - no update
    EXPECT_CALL(*mockModbus, task()).Times(1);
    for (int i = 0; i < NUM_MOTORS; i++) {
        EXPECT_CALL(*mockMotors[i], update()).Times(0);
    }
    systemCore->loop();
    
    // Advance 100ms
    advanceTime(100);
    
    // Second call - motors should update
    EXPECT_CALL(*mockModbus, task()).Times(1);
    for (int i = 0; i < NUM_MOTORS; i++) {
        EXPECT_CALL(*mockMotors[i], update()).Times(1);
    }
    systemCore->loop();
}

TEST_F(SystemCoreTest, SensorUpdateTiming) {
    // First call - no sensor update
    EXPECT_CALL(*mockModbus, task()).Times(1);
    EXPECT_CALL(mockAirSensor, update()).Times(0);
    EXPECT_CALL(mockWaterSensor, update()).Times(0);
    for (int i = 0; i < NUM_MOTORS; i++) {
        EXPECT_CALL(*mockMotorSensors[i], update()).Times(0);
    }
    systemCore->loop();
    
    // Advance 1000ms
    advanceTime(1000);
    
    // Second call - sensors should update
    EXPECT_CALL(*mockModbus, task()).Times(1);
    EXPECT_CALL(mockAirSensor, update()).Times(1);
    EXPECT_CALL(mockWaterSensor, update()).Times(1);
    for (int i = 0; i < NUM_MOTORS; i++) {
        EXPECT_CALL(*mockMotorSensors[i], requestTemperatures(_)).Times(1);
        EXPECT_CALL(*mockMotorSensors[i], update()).Times(1);
    }
    EXPECT_CALL(*mockDeviceManager, update(_, _, _)).Times(1);
    
    // Expect time registers to be updated
    EXPECT_CALL(*mockModbus, setIreg(ModbusReg::TIME_LOW, currentTestTime & 0xFFFF)).Times(1);
    EXPECT_CALL(*mockModbus, setIreg(ModbusReg::TIME_LOW + 1, (currentTestTime >> 16) & 0xFFFF)).Times(1);
    EXPECT_CALL(*mockModbus, setIreg(ModbusReg::TIME_LOW + 2, (currentTestTime >> 32) & 0xFFFF)).Times(1);
    EXPECT_CALL(*mockModbus, setIreg(ModbusReg::TIME_LOW + 3, (currentTestTime >> 48) & 0xFFFF)).Times(1);
    
    systemCore->loop();
}

TEST_F(SystemCoreTest, EmergencyShutdown) {
    // Simulate emergency stop command via Modbus
    EXPECT_CALL(*mockModbus, getHreg(ModbusReg::START_REG_ADDR))
        .WillOnce(Return(0));  // Stop command
    
    // Expect all motors to be stopped
    for (int i = 0; i < NUM_MOTORS; i++) {
        EXPECT_CALL(*mockMotors[i], setDuty(0)).Times(1);
    }
    
    // Expect all devices to be turned off
    EXPECT_CALL(*mockDeviceManager, controlFan(false)).Times(1);
    EXPECT_CALL(*mockDeviceManager, controlMixer(false)).Times(1);
    EXPECT_CALL(*mockDeviceManager, controlDispenser(false)).Times(1);
    EXPECT_CALL(*mockDeviceManager, controlPump(false)).Times(1);
    
    systemCore->loop();
}

================================================================================
File: test\test_TemperatureSensor\test_mocks.cpp
================================================================================

#include "DallasTemperature.h"
#include "OneWire.h"

// Mock OneWire (minimal implementation)
OneWire::OneWire(uint8_t pin) {}
uint8_t OneWire::reset(void) { return 1; }

// Mock DallasTemperature
DallasTemperature_Mock::DallasTemperature_Mock() {}
void DallasTemperature_Mock::begin() {}
void DallasTemperature_Mock::requestTemperatures() {}
float DallasTemperature_Mock::getTempCByIndex(uint8_t) { return mockTemp; }

================================================================================
File: test\test_TemperatureSensor\test_TemperatureSensor.cpp
================================================================================

#include <unity.h>
#include "TemperatureSensor.h"
#include "ModbusHandler.h"
#include "test_mocks.h"  // Mocks for OneWire/DallasTemperature

// Mock ModbusHandler
ModbusHandler* modbusHandler = nullptr;
class MockModbusHandler : public ModbusHandler {
public:
    MockModbusHandler() : ModbusHandler(Serial, 1) {}
    uint16_t getHreg(uint16_t addr) override { return thresholds[addr]; }
    void setIreg(uint16_t addr, uint16_t value) override { ireg[addr] = value; }
    uint16_t thresholds[1000] = {0};
    uint16_t ireg[1000] = {0};
};

// Mock DallasTemperature
void DallasTemperature_Mock::setTempC(float temp) { mockTemp = temp; }

void test_sensor_disconnected() {
    DallasTemperature_Mock sensorMock;
    sensorMock.setTempC(DEVICE_DISCONNECTED_C);
    TemperatureSensor sensor(0, 0, 0, 0);
    sensor.sensor = &sensorMock;  // Inject mock
    
    sensor.update();
    TEST_ASSERT_EQUAL(3, sensor.getStatus());  // Should be error state
    TEST_ASSERT_EQUAL(0xFFFF, modbusHandler->ireg[0]);
}

void test_temperature_thresholds() {
    DallasTemperature_Mock sensorMock;
    MockModbusHandler mb;
    modbusHandler = &mb;
    
    TemperatureSensor sensor(0, 100, 200, 300);
    sensor.sensor = &sensorMock;
    
    // Set thresholds
    mb.thresholds[200] = 1000;  // Low threshold (10.00°C)
    mb.thresholds[300] = 3000;  // High threshold (30.00°C)

    // Test normal temperature
    sensorMock.setTempC(20.0f);
    sensor.update();
    TEST_ASSERT_EQUAL(0, sensor.getStatus());

    // Test high temperature
    sensorMock.setTempC(31.0f);
    sensor.update();
    TEST_ASSERT_EQUAL(2, sensor.getStatus());
}

int main() {
    UNITY_BEGIN();
    RUN_TEST(test_sensor_disconnected);
    RUN_TEST(test_temperature_thresholds);
    return UNITY_END();
}

================================================================================
File: test\test_SystemCore\mocks\MockDeviceManager.h
================================================================================

#pragma once
#include "DeviceManager.h"
#include <gmock/gmock.h>

class MockDeviceManager : public DeviceManager {
public:
    MOCK_METHOD(void, begin, (), (override));
    MOCK_METHOD(void, update, (const TemperatureSensor& airSensor, 
                              const TemperatureSensor& waterSensor, 
                              const Motor* const* motors), (override));
};

================================================================================
File: test\test_SystemCore\mocks\MockModbusHandler.h
================================================================================

#pragma once
#include "ModbusHandler.h"
#include <gmock/gmock.h>

class MockModbusHandler : public ModbusHandler {
public:
    MockModbusHandler() : ModbusHandler(Serial, 1) {}
    
    MOCK_METHOD(void, begin, (unsigned long baudrate), (override));
    MOCK_METHOD(void, task, (), (override));
    MOCK_METHOD(uint16_t, getHreg, (uint16_t addr), (override));
    MOCK_METHOD(uint16_t, getIreg, (uint16_t addr), (override));
    MOCK_METHOD(void, setHreg, (uint16_t addr, uint16_t value), (override));
    MOCK_METHOD(void, setIreg, (uint16_t addr, uint16_t value), (override));
};

================================================================================
File: test\test_SystemCore\mocks\MockMotor.h
================================================================================

#pragma once
#include "Motor.h"
#include <gmock/gmock.h>

class MockMotor : public Motor {
public:
    MockMotor() : Motor(0, 0, 0, nullptr) {}
    
    MOCK_METHOD(void, begin, (), (override));
    MOCK_METHOD(void, update, (), (override));
    MOCK_METHOD(void, setDuty, (uint16_t duty), (override));
    MOCK_METHOD(void, setFrequency, (uint32_t freq), (override));
    MOCK_METHOD(uint8_t, getStatus, (), (const override));
};

================================================================================
File: test\test_SystemCore\mocks\MockTemperatureSensor.h
================================================================================

#pragma once
#include "TemperatureSensor.h"
#include <gmock/gmock.h>

class MockTemperatureSensor : public TemperatureSensor {
public:
    MockTemperatureSensor() : TemperatureSensor(0, 0, 0, 0) {}
    
    MOCK_METHOD(void, begin, (), (override));
    MOCK_METHOD(void, requestTemperatures, (uint64_t now), (override));
    MOCK_METHOD(void, update, (), (override));
    MOCK_METHOD(int16_t, getTemperature, (), (const override));
    MOCK_METHOD(uint8_t, getStatus, (), (const override));
};
